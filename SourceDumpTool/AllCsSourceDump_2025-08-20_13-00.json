{
    "scannedFolder": "Assets/Scripts",
    "generatedAt": "2025-08-20T11:00:11.3663005Z",
    "mode": "All",
    "scripts": [
        {
            "kind": 0,
            "className": "CameraSwitcher",
            "namespace": "",
            "fullName": "CameraSwitcher",
            "filePath": "Assets/Scripts/Camera Scripts/CameraSwitcher.cs",
            "guid": "78abdc146e0c6874b872467bd2472b5a",
            "source": "using UnityEngine;\r\nusing Unity.Cinemachine;\r\n\r\npublic class CameraSwitcher : MonoBehaviour\r\n{\r\n    [SerializeField] private CinemachineCamera exteriorCamera;\r\n    [SerializeField] private CinemachineCamera interiorCamera;\r\n    [SerializeField] private Camera mainCamera;\r\n\r\n    private CinemachineBrain brain;\r\n    [SerializeField] private float switchCooldown = 1.0f; // seconds\r\n    private float lastSwitchTime = -Mathf.Infinity;\r\n    private bool isInside = false;\r\n\r\n    private void Start()\r\n    {\r\n        // Get the CinemachineBrain component\r\n        brain = mainCamera.GetComponent<CinemachineBrain>();\r\n        // Set blink/instant transition\r\n        SetInstantSwitch();\r\n\r\n        // Initialize priorities\r\n        exteriorCamera.Priority = 10;\r\n        interiorCamera.Priority = 0;\r\n        mainCamera.orthographic = true;\r\n    }\r\n\r\n    private void OnTriggerEnter(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\") && Time.time - lastSwitchTime > switchCooldown)\r\n        {\r\n            isInside = true;\r\n            SwitchToInteriorCamera();\r\n            lastSwitchTime = Time.time;\r\n        }\r\n    }\r\n\r\n    private void OnTriggerExit(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\") && Time.time - lastSwitchTime > switchCooldown)\r\n        {\r\n            isInside = false;\r\n            SwitchToExteriorCamera();\r\n            lastSwitchTime = Time.time;\r\n        }\r\n    }\r\n\r\n    private void SetInstantSwitch()\r\n    {\r\n        var blend = new CinemachineBlendDefinition(CinemachineBlendDefinition.Styles.Cut, 0);\r\n        if (brain != null)\r\n        {\r\n            brain.DefaultBlend = blend;\r\n        }\r\n    }\r\n\r\n    private void SwitchToInteriorCamera()\r\n    {\r\n        interiorCamera.Priority = 10;\r\n        exteriorCamera.Priority = 0;\r\n        mainCamera.orthographic = false;\r\n        SetInstantSwitch();\r\n    }\r\n\r\n    private void SwitchToExteriorCamera()\r\n    {\r\n        exteriorCamera.Priority = 10;\r\n        interiorCamera.Priority = 0;\r\n        mainCamera.orthographic = true;\r\n        SetInstantSwitch();\r\n    }\r\n}",
            "serializedFields": [
                {
                    "name": "exteriorCamera",
                    "type": "Unity.Cinemachine.CinemachineCamera",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "interiorCamera",
                    "type": "Unity.Cinemachine.CinemachineCamera",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "mainCamera",
                    "type": "UnityEngine.Camera",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "switchCooldown",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "CameraSwitcher"
            ]
        },
        {
            "kind": 0,
            "className": "ClueManager",
            "namespace": "",
            "fullName": "ClueManager",
            "filePath": "Assets/Scripts/DataScripts/ClueManager.cs",
            "guid": "e84cd69b3cf44b54b9b20a47daf4b0f4",
            "source": "using UnityEngine;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing UnityEngine.SceneManagement;\r\n// ...\r\n\r\n[DefaultExecutionOrder(-900)] // Runs after SaveSystem, before most gameplay\r\npublic class ClueManager : MonoBehaviour\r\n{\r\n    public static ClueManager Instance { get; private set; }\r\n\r\n    [Header(\"References\")]\r\n    [SerializeField] private CognitionBoard cognitionBoard; // Assign in Inspector\r\n\r\n    public event Action<ClueData> OnClueDiscovered;\r\n\r\n    private readonly Dictionary<string, ClueData> discovered = new();\r\n\r\n    private readonly Queue<ClueData> _pendingAdds = new();\r\n\r\nprivate bool EnsureBoard()\r\n{\r\n    if (cognitionBoard) return true;\r\n\r\n    // Find even if the board object is inactive (it starts inactive in Awake)\r\n#if UNITY_2022_1_OR_NEWER\r\n    cognitionBoard = FindFirstObjectByType<CognitionBoard>(FindObjectsInactive.Include);\r\n#else\r\n    cognitionBoard = Resources.FindObjectsOfTypeAll<CognitionBoard>()?.Length > 0\r\n        ? Resources.FindObjectsOfTypeAll<CognitionBoard>()[0]\r\n        : null;\r\n#endif\r\n    return cognitionBoard != null;\r\n}\r\n\r\nprivate void FlushPending()\r\n{\r\n    if (!cognitionBoard) return;\r\n    while (_pendingAdds.Count > 0)\r\n    {\r\n        var data = _pendingAdds.Dequeue();\r\n        cognitionBoard.AddNode(data);\r\n        cognitionBoard.AddSuggestedConnectionsFor(data.Guid);\r\n    }\r\n}\r\n\r\n\r\n    private void Awake()\r\n    {\r\n        if (Instance && Instance != this)\r\n        {\r\n            Destroy(gameObject);\r\n            return;\r\n        }\r\n\r\n        Instance = this;\r\n        DontDestroyOnLoad(gameObject);\r\n    }\r\n\r\n    private void OnEnable()\r\n{\r\n    SceneManager.sceneLoaded += OnSceneLoaded;\r\n}\r\n\r\nprivate void OnDisable()\r\n{\r\n    SceneManager.sceneLoaded -= OnSceneLoaded;\r\n}\r\n\r\nprivate void OnSceneLoaded(Scene s, LoadSceneMode m)\r\n{\r\n    if (EnsureBoard()) FlushPending();\r\n}\r\n\r\n    public bool HasClue(string guid) => discovered.ContainsKey(guid);\r\n\r\n    public void DiscoverClue(ClueData data)\r\n{\r\n    if (data == null) return;\r\n    if (HasClue(data.Guid)) return;\r\n\r\n    discovered.Add(data.Guid, data);\r\n    SaveSystem.Instance?.MarkClueDiscovered(data.Guid);\r\n\r\n    if (!EnsureBoard())\r\n    {\r\n        // Board not in this scene yet — remember to add as soon as it appears.\r\n        _pendingAdds.Enqueue(data);\r\n        return;\r\n    }\r\n\r\n    cognitionBoard.AddNode(data);\r\n    cognitionBoard.AddSuggestedConnectionsFor(data.Guid);\r\n\r\n    OnClueDiscovered?.Invoke(data);\r\n}\r\n    public void RestoreFromSave(IEnumerable<string> guids, Func<string, ClueData> resolver)\r\n{\r\n    if (resolver == null) return;\r\n\r\n    foreach (var g in guids)\r\n    {\r\n        if (discovered.ContainsKey(g)) continue;\r\n\r\n        var data = resolver(g);\r\n        if (data != null)\r\n        {\r\n            discovered[g] = data;\r\n\r\n            if (!EnsureBoard())\r\n            {\r\n                _pendingAdds.Enqueue(data);\r\n            }\r\n            else\r\n            {\r\n                cognitionBoard.AddNode(data);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            Debug.LogWarning($\"[ClueManager] Could not resolve clue GUID '{g}' to a ClueData asset.\");\r\n        }\r\n    }\r\n\r\n    // Once nodes are ensured, rebuild autos\r\n    if (EnsureBoard())\r\n    {\r\n        cognitionBoard.BuildAllAutoConnections();\r\n    }\r\n}\r\n\r\n\r\n    public ClueData GetClue(string guid)\r\n    {\r\n        discovered.TryGetValue(guid, out var data);\r\n        return data;\r\n    }\r\n\r\n    public void ClearAllRuntime()\r\n{\r\n    // Clear discovered cache\r\n    discovered.Clear();\r\n\r\n    // Clear the visual board too (if it's around)\r\n    cognitionBoard?.ClearAll();\r\n}\r\n\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "cognitionBoard",
                    "type": "CognitionBoard",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "ClueManager"
            ]
        },
        {
            "kind": 0,
            "className": "ClueNode",
            "namespace": "",
            "fullName": "ClueNode",
            "filePath": "Assets/Scripts/Draft UI Scripts/ClueNode.cs",
            "guid": "afbd9a795cbb8314f9a2bb776091ef3b",
            "source": "using UnityEngine;\r\nusing UnityEngine.UI;\r\nusing TMPro;\r\nusing UnityEngine.EventSystems;\r\n\r\n[RequireComponent(typeof(RectTransform))]\r\npublic class ClueNode : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler\r\n{\r\n    public enum VisualStyle { CompactCircle, WideWithTitle }\r\n\r\n    [Header(\"Visual\")]\r\n    [SerializeField] private VisualStyle style = VisualStyle.CompactCircle;\r\n    [SerializeField] private bool showTitle = false;     // <- off by default\r\n\r\n    private RectTransform rect;\r\n    private Image iconImage;\r\n    private RectTransform iconRect;                      // <- center anchor for lines\r\n    private Image categoryRing;\r\n    private TMP_Text titleText;\r\n    private CognitionBoard board;\r\n\r\n    public string ClueGuid { get; private set; }\r\n    public RectTransform Rect => rect;\r\n    public RectTransform LineAnchor => iconRect ? iconRect : rect;  // <- for lines\r\n    public ClueData Data { get; private set; }\r\n\r\n    private static Sprite _runtimeDefaultSprite;\r\n\r\n    void Awake()\r\n    {\r\n        rect = GetComponent<RectTransform>();\r\n        EnsureUIExists();\r\n        ApplyStyle();\r\n    }\r\n\r\n    private void EnsureUIExists()\r\n    {\r\n        // background (optional)\r\n        if (!TryGetComponent<Image>(out _))\r\n        {\r\n            var bg = gameObject.AddComponent<Image>();\r\n            bg.raycastTarget = true;\r\n            bg.color = new Color(0f, 0f, 0f, 0.0f); // fully transparent by default\r\n        }\r\n\r\n        // Icon (the circular photo)\r\n        iconRect = (transform.Find(\"Icon\") as RectTransform);\r\n        if (!iconRect)\r\n        {\r\n            iconRect = new GameObject(\"Icon\", typeof(RectTransform), typeof(Image)).GetComponent<RectTransform>();\r\n            iconRect.SetParent(transform, false);\r\n        }\r\n        iconImage = iconRect.GetComponent<Image>();\r\n        iconImage.preserveAspect = true;\r\n        iconRect.anchorMin = iconRect.anchorMax = new Vector2(0.5f, 0.5f);\r\n        iconRect.pivot = new Vector2(0.5f, 0.5f);\r\n        iconRect.anchoredPosition = Vector2.zero;\r\n\r\n        // Ring overlay\r\n        var ringRect = (transform.Find(\"Ring\") as RectTransform);\r\n        if (!ringRect)\r\n        {\r\n            ringRect = new GameObject(\"Ring\", typeof(RectTransform), typeof(Image)).GetComponent<RectTransform>();\r\n            ringRect.SetParent(transform, false);\r\n        }\r\n        categoryRing = ringRect.GetComponent<Image>();\r\n        categoryRing.raycastTarget = false;\r\n        ringRect.anchorMin = ringRect.anchorMax = new Vector2(0.5f, 0.5f);\r\n        ringRect.pivot = new Vector2(0.5f, 0.5f);\r\n        ringRect.anchoredPosition = Vector2.zero;\r\n\r\n        // Title (optional)\r\n        var title = transform.Find(\"Title\") as RectTransform;\r\n        if (!title)\r\n        {\r\n            title = new GameObject(\"Title\", typeof(RectTransform), typeof(TextMeshProUGUI)).GetComponent<RectTransform>();\r\n            title.SetParent(transform, false);\r\n        }\r\n        titleText = title.GetComponent<TextMeshProUGUI>();\r\n        if (titleText)\r\n        {\r\n            titleText.textWrappingMode = TextWrappingModes.Normal;\r\n            titleText.alignment = TextAlignmentOptions.MidlineLeft;\r\n        }\r\n\r\n        if (!rect) rect = GetComponent<RectTransform>();\r\n\r\n        var def = GetDefaultSprite();\r\n\r\n// Force every Image under this node to have *some* sprite so it can render\r\nvar images = GetComponentsInChildren<Image>(true);\r\nforeach (var img in images)\r\n{\r\n    if (!img) continue;\r\n    if (img.sprite == null) img.sprite = def;\r\n\r\n    // If someone left alpha at 0, the Image will be invisible—bump it.\r\n    var c = img.color;\r\n    if (c.a <= 0f) { c.a = 1f; img.color = c; }\r\n\r\n    // Optional: these UI elements don’t need to block clicks\r\n    img.raycastTarget = false;\r\n}\r\n\r\n// If you have named fields (iconImage, ringImage, bgImage), you can still\r\n// keep the same logic—just use `def` instead of Resources.GetBuiltinResource.\r\n        if (categoryRing && categoryRing.sprite == null) categoryRing.sprite = def;\r\n    }\r\n\r\n    private void ApplyStyle()\r\n    {\r\n        if (!rect) rect = GetComponent<RectTransform>();\r\n\r\n        if (style == VisualStyle.CompactCircle)\r\n        {\r\n            // Square node; centered icon + ring\r\n            rect.sizeDelta = new Vector2(110, 110);\r\n            iconRect.sizeDelta = new Vector2(100, 100);\r\n            if (categoryRing) categoryRing.rectTransform.sizeDelta = new Vector2(112, 112);\r\n            if (titleText) titleText.gameObject.SetActive(false);\r\n        }\r\n        else // WideWithTitle\r\n        {\r\n            rect.sizeDelta = new Vector2(300, 110);\r\n            iconRect.sizeDelta = new Vector2(90, 90);\r\n            iconRect.anchoredPosition = new Vector2(-90, 0);\r\n            if (categoryRing) categoryRing.rectTransform.sizeDelta = new Vector2(100, 100);\r\n\r\n            if (titleText)\r\n            {\r\n                titleText.gameObject.SetActive(showTitle);\r\n                titleText.rectTransform.sizeDelta = new Vector2(180, 80);\r\n                titleText.rectTransform.anchoredPosition = new Vector2(40, 0);\r\n                titleText.alignment = TextAlignmentOptions.MidlineLeft;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void Initialize(CognitionBoard owner, ClueData data)\r\n    {\r\n        if (!rect || !iconRect || !iconImage || !categoryRing) { EnsureUIExists(); ApplyStyle(); }\r\n\r\n        board = owner;\r\n        Data = data;\r\n        ClueGuid = data.Guid;\r\n\r\n        // Fill from data\r\n        if (iconImage) iconImage.sprite = data.icon;    // null OK\r\n\r\n        if (categoryRing)\r\n        {\r\n            categoryRing.color = data.category switch\r\n            {\r\n                ClueData.ClueCategory.Person => new Color(0.85f, 0.20f, 0.20f),\r\n                ClueData.ClueCategory.Object => new Color(0.20f, 0.70f, 1.00f),\r\n                ClueData.ClueCategory.Location => new Color(0.20f, 0.90f, 0.50f),\r\n                ClueData.ClueCategory.Event => new Color(1.00f, 0.80f, 0.20f),\r\n                _ => Color.white\r\n            };\r\n        }\r\n\r\n        if (titleText)\r\n        {\r\n            titleText.text = string.IsNullOrWhiteSpace(data.clueName) ? \"\" : data.clueName;\r\n            titleText.gameObject.SetActive(showTitle && style == VisualStyle.WideWithTitle);\r\n        }\r\n\r\n        // spawn at a random point so new nodes don't stack\r\n        rect.anchoredPosition = Random.insideUnitCircle * 300f;\r\n    }\r\n\r\n    // Selection feedback (tiny scale bump)\r\n    public void SetSelected(bool sel)\r\n    {\r\n        transform.localScale = sel ? Vector3.one * 1.08f : Vector3.one;\r\n    }\r\n\r\n    // --- Drag handling ---\r\n    public void OnBeginDrag(PointerEventData e) { board?.BeginNodeDrag(this); }\r\n    public void OnDrag(PointerEventData e)\r\n    {\r\n        if (board == null || Rect == null) return;\r\n        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(board.ContentRect, e.position, e.pressEventCamera, out var lp))\r\n        {\r\n            Rect.anchoredPosition = lp;\r\n            board.OnNodeMoved(this);\r\n        }\r\n    }\r\n    public void OnEndDrag(PointerEventData e) { board?.EndNodeDrag(this); }\r\n    \r\n    private static Sprite GetDefaultSprite()\r\n{\r\n    if (_runtimeDefaultSprite != null) return _runtimeDefaultSprite;\r\n\r\n    // Try Editor-only built-in first (nice to have, but optional)\r\n    #if UNITY_EDITOR\r\n    // Works in Editor; safe to fail in Player.\r\n    var editorSprite = UnityEditor.AssetDatabase.GetBuiltinExtraResource<Sprite>(\"UI/Skin/UISprite.psd\");\r\n    if (editorSprite != null) { _runtimeDefaultSprite = editorSprite; return _runtimeDefaultSprite; }\r\n    #endif\r\n\r\n    // Guaranteed runtime fallback: create a tiny white sprite\r\n    const int W = 16, H = 16;\r\n    var tex = new Texture2D(W, H, TextureFormat.ARGB32, false);\r\n    var pixels = new Color32[W * H];\r\n    for (int i = 0; i < pixels.Length; i++) pixels[i] = new Color32(255, 255, 255, 255);\r\n    tex.SetPixels32(pixels);\r\n    tex.Apply(false, true);\r\n    tex.name = \"DefaultUISpriteRuntime\";\r\n\r\n    _runtimeDefaultSprite = Sprite.Create(tex, new Rect(0, 0, W, H), new Vector2(0.5f, 0.5f), 100f);\r\n    _runtimeDefaultSprite.name = \"DefaultUISpriteRuntime\";\r\n    return _runtimeDefaultSprite;\r\n}\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "style",
                    "type": "ClueNode+VisualStyle",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "showTitle",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "ClueNode",
                "VisualStyle"
            ]
        },
        {
            "kind": 0,
            "className": "CognitionBoard",
            "namespace": "",
            "fullName": "CognitionBoard",
            "filePath": "Assets/Scripts/Draft UI Scripts/CognitionBoard.cs",
            "guid": "20d9c282248487240ae5649a4ba6941a",
            "source": "using UnityEngine;\r\nusing System.Collections.Generic;\r\nusing UnityEngine.InputSystem;\r\n\r\npublic class CognitionBoard : MonoBehaviour\r\n{\r\n    [Header(\"UI\")]\r\n    [SerializeField] private RectTransform contentRect;\r\n    [SerializeField] private ClueNode nodePrefab;\r\n    [SerializeField] private ConnectionLineUI linePrefab;\r\n\r\n    [Header(\"Line Style\")]\r\n    [SerializeField] private Color suggestedColor = new(0.90f, 0.25f, 0.25f, 1f);\r\n    [SerializeField] private float suggestedWidth = 4f;\r\n    [SerializeField] private Color confirmedColor = new(0.20f, 0.90f, 0.35f, 1f);\r\n    [SerializeField] private float confirmedWidth = 5.5f;\r\n\r\n    [Header(\"Reveal (play on open)\")]\r\n    [SerializeField] private bool playRevealOnOpen = true;\r\n    [SerializeField] private float revealDurationPerLine = 0.35f;\r\n    [SerializeField] private float revealStagger = 0.10f;\r\n    [SerializeField] private float nodePopDuration = 0.22f;\r\n    [SerializeField] private float nodePopStagger = 0.05f;\r\n\r\n    [Header(\"Navigation (UI map)\")]\r\n    [SerializeField] private InputActionReference navigateAction;\r\n    [SerializeField] private InputActionReference submitAction;\r\n\r\n    [Header(\"Zoom Input\")]\r\n    [SerializeField] private InputActionReference zoomAction; // Scroll wheel or pinch\r\n\r\n    [Header(\"Navigation Tuning\")]\r\n    [SerializeField] private float navDeadZone = 0.5f;\r\n    [SerializeField] private float navFirstDelay = 0.25f;   // reserved\r\n    [SerializeField] private float navRepeat = 0.15f;\r\n    [SerializeField] private float dirConeDegrees = 70f;\r\n    [SerializeField] private float minHopDistance = 30f;\r\n    [SerializeField] private float selectedScale = 1.08f;\r\n    [SerializeField] private bool centerOnSubmit = true;\r\n\r\n    [Header(\"Viewport & Placement\")]\r\n    [SerializeField] private RectTransform viewportRect;     // visible area (optional, for centering)\r\n    [SerializeField] private float minNodeSpacing = 140f;    // minimum distance between nodes\r\n    [SerializeField] private float relatedMaxDistance = 420f;// cap distance from related centroid\r\n    [SerializeField] private float spawnRadiusStart = 80f;\r\n    [SerializeField] private float spawnRadiusStep = 60f;\r\n    [SerializeField] private float spawnRadiusMax = 1200f;\r\n\r\n    [Header(\"Zoom\")]\r\n    [SerializeField, Range(0.25f, 3f)] private float minZoom = 0.5f;\r\n    [SerializeField, Range(0.25f, 3f)] private float maxZoom = 2.0f;\r\n    [SerializeField] private float zoomStep = 0.1f;\r\n\r\n    // ---------- NEW: Follow selected (always centered, with easing) ----------\r\n    [Header(\"Follow Selected\")]\r\n    [SerializeField] private bool keepSelectedCentered = true;\r\n    [Tooltip(\"SmoothDamp time (seconds) for the board to catch the selected node.\")]\r\n    [SerializeField, Min(0f)] private float panDampTime = 0.18f;\r\n    [Tooltip(\"Don’t chase tiny differences; prevents micro-jitter.\")]\r\n    [SerializeField, Min(0f)] private float panDeadZone = 0.75f; // in content units (pixels in content space)\r\n    [Tooltip(\"Pause following while a node is being dragged.\")]\r\n    [SerializeField] private bool disableFollowWhileDragging = true;\r\n\r\n    private Vector2 panVelocity;   // SmoothDamp velocity\r\n    private bool isDraggingNode;\r\n\r\n    public RectTransform ContentRect => contentRect ? contentRect : (RectTransform)transform;\r\n    public float CurrentZoom => ContentRect ? ContentRect.localScale.x : 1f;\r\n\r\n    private readonly List<(string, string)> pendingLineReveals = new(); // ORDERED\r\n    private readonly HashSet<(string, string)> pendingLineSet = new();  // uniqueness\r\n    private readonly List<string> pendingNodePops = new();              // ORDERED\r\n\r\n    private readonly Dictionary<string, ClueNode> nodes = new();\r\n    private readonly Dictionary<(string, string), ConnectionLineUI> lines = new();\r\n\r\n    private RectTransform linesLayer;\r\n    private RectTransform nodesLayer;\r\n\r\n    // selection\r\n    private string selectedGuid;\r\n    private ClueNode selectedNode;\r\n    private Vector2 lastNavDir;\r\n    private float nextNavTime;\r\n    private bool navHeld;\r\n    private float cosCone;\r\n\r\n    private void Awake()\r\n    {\r\n        gameObject.SetActive(false);\r\n        if (!contentRect) contentRect = GetComponent<RectTransform>();\r\n        if (!contentRect) Debug.LogError(\"[CognitionBoard] No RectTransform for content.\", this);\r\n        EnsureLayers();\r\n        cosCone = Mathf.Cos(dirConeDegrees * Mathf.Deg2Rad);\r\n    }\r\n\r\n    private void OnEnable()\r\n    {\r\n        try { navigateAction?.action?.Enable(); } catch { }\r\n        try { submitAction?.action?.Enable(); } catch { }\r\n        try { zoomAction?.action?.Enable(); } catch { }\r\n\r\n        navHeld = false; nextNavTime = 0f;\r\n        // Don’t snap; the follow code will glide us to the current selection.\r\n        if (selectedNode == null) AutoSelectClosestToCenter();\r\n    }\r\n\r\n    private void OnDisable()\r\n    {\r\n        if (selectedNode) selectedNode.Rect.localScale = Vector3.one;\r\n        selectedNode = null;\r\n        selectedGuid = null;\r\n        navHeld = false; nextNavTime = 0f;\r\n\r\n        try { zoomAction?.action?.Disable(); } catch { }\r\n    }\r\n\r\n    private void EnsureLayers()\r\n    {\r\n        linesLayer = FindOrCreateLayer(\"Lines\", 0);\r\n        nodesLayer = FindOrCreateLayer(\"Nodes\", 1);\r\n    }\r\n    private RectTransform FindOrCreateLayer(string name, int siblingIndex)\r\n    {\r\n        var t = ContentRect.Find(name) as RectTransform;\r\n        if (!t)\r\n        {\r\n            var go = new GameObject(name, typeof(RectTransform));\r\n            t = go.GetComponent<RectTransform>();\r\n            t.SetParent(ContentRect, false);\r\n            t.anchorMin = Vector2.zero; t.anchorMax = Vector2.one;\r\n            t.offsetMin = Vector2.zero; t.offsetMax = Vector2.zero;\r\n        }\r\n        t.SetSiblingIndex(siblingIndex);\r\n        return t;\r\n    }\r\n\r\n    // ---------- Public API ----------\r\n    public void AddNode(ClueData data)\r\n    {\r\n        if (!data) { Debug.LogError(\"[CognitionBoard] AddNode null data\"); return; }\r\n        if (nodes.ContainsKey(data.Guid)) { BuildAutoLinksTouching(data.Guid); return; }\r\n\r\n        // Ensure the nodes layer exists\r\n        if (!nodesLayer) EnsureLayers();\r\n\r\n        ClueNode node;\r\n        if (nodePrefab)\r\n        {\r\n            node = Instantiate(nodePrefab, nodesLayer); // parents with worldPositionStays = false\r\n            // normalize anchors/pivot in case prefab differs\r\n            if (node.Rect)\r\n            {\r\n                var rt = node.Rect;\r\n                rt.anchorMin = rt.anchorMax = rt.pivot = new Vector2(0.5f, 0.5f);\r\n                rt.localScale = Vector3.one;\r\n                rt.localRotation = Quaternion.identity;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var go = new GameObject($\"ClueNode_{data.clueName}\", typeof(RectTransform), typeof(ClueNode));\r\n            var rt = go.GetComponent<RectTransform>();\r\n            rt.SetParent(nodesLayer, false);                       // CRITICAL\r\n            rt.anchorMin = rt.anchorMax = rt.pivot = new Vector2(0.5f, 0.5f);\r\n            rt.localScale = Vector3.one;\r\n            rt.localRotation = Quaternion.identity;\r\n            node = go.GetComponent<ClueNode>();\r\n        }\r\n\r\n        node.Initialize(this, data);\r\n\r\n        // --- initial placement (on-screen & spaced) ---\r\n        bool hasSaved = false;\r\n        try\r\n        {\r\n            // e.g.: hasSaved = SaveSystem.Instance?.TryGetNodePosition(data.Guid, out var _) == true;\r\n        }\r\n        catch { }\r\n\r\n        if (!hasSaved && node.Rect && ContentRect)\r\n        {\r\n            Vector2 seed = GetViewCenterLocal();\r\n\r\n            if (TryGetExistingRelatedCentroid(data, out var centroid))\r\n            {\r\n                Vector2 start = ClampWithinRelatedMax(seed, centroid, relatedMaxDistance);\r\n                node.Rect.anchoredPosition = FindFreeSpot(start, minNodeSpacing);\r\n            }\r\n            else\r\n            {\r\n                node.Rect.anchoredPosition = FindFreeSpot(seed, minNodeSpacing);\r\n            }\r\n        }\r\n\r\n        nodes.Add(data.Guid, node);\r\n\r\n        // Queue pop if board is closed (so it animates next open)\r\n        if (!gameObject.activeInHierarchy && playRevealOnOpen)\r\n        {\r\n            node.Rect.localScale = Vector3.zero;\r\n            if (!pendingNodePops.Contains(data.Guid))\r\n                pendingNodePops.Add(data.Guid);\r\n        }\r\n\r\n        BuildAutoLinksTouching(data.Guid);\r\n\r\n        if (isActiveAndEnabled && selectedNode == null)\r\n            SelectNodeInternal(node);\r\n    }\r\n\r\n    public void BeginNodeDrag(ClueNode _)\r\n    {\r\n        if (disableFollowWhileDragging) isDraggingNode = true;\r\n    }\r\n    public void OnNodeMoved(ClueNode _) { }\r\n    public void EndNodeDrag(ClueNode node)\r\n    {\r\n        if (disableFollowWhileDragging) isDraggingNode = false;\r\n        SaveSystem.Instance?.SetNodePosition(node.ClueGuid, node.Rect.anchoredPosition);\r\n    }\r\n\r\n    // restore pan/zoom/positions (leave lines for reveal system)\r\n    public void RestoreLayoutFromSave(bool rebuildLines = false)\r\n    {\r\n        var layout = SaveSystem.Instance?.GetBoardLayout();\r\n        if (layout == null) return;\r\n\r\n        ContentRect.localScale = Vector3.one * layout.zoom;\r\n        ContentRect.anchoredPosition = layout.pan;\r\n\r\n        foreach (var kvp in layout.nodePositions)\r\n            if (nodes.TryGetValue(kvp.Key, out var node))\r\n                node.Rect.anchoredPosition = kvp.Value;\r\n\r\n        if (rebuildLines) RebuildAllAutoLinks();\r\n        AutoSelectClosestToCenter();\r\n    }\r\n\r\n    // Called by PauseMenuController right after opening the board\r\n    public void NotifyBoardOpened()\r\n    {\r\n        if (!playRevealOnOpen) { pendingNodePops.Clear(); pendingLineReveals.Clear(); pendingLineSet.Clear(); return; }\r\n        if (!gameObject.activeInHierarchy) return;\r\n        if (pendingNodePops.Count == 0 && pendingLineReveals.Count == 0) return;\r\n\r\n        StopAllCoroutines();\r\n        StartCoroutine(PlayOpenRevealSequence());\r\n    }\r\n\r\n    // ---------- Update (navigation + zoom + follow) ----------\r\n    private void Update()\r\n    {\r\n        if (!isActiveAndEnabled || nodes.Count == 0) return;\r\n\r\n        // --- Directional selection (left stick / keys) ---\r\n        Vector2 dir = Vector2.zero;\r\n        try { dir = navigateAction ? navigateAction.action.ReadValue<Vector2>() : Vector2.zero; } catch { }\r\n        float mag = dir.magnitude;\r\n        float now = Time.unscaledTime;\r\n\r\n        if (mag > navDeadZone)\r\n        {\r\n            Vector2 norm = dir / mag;\r\n            if (!navHeld || now >= nextNavTime || Vector2.Dot(norm, lastNavDir) < 0.65f)\r\n            {\r\n                lastNavDir = norm;\r\n                bool moved = MoveSelectionInDirection(norm);\r\n                navHeld = true;\r\n                nextNavTime = now + (moved ? navRepeat : navRepeat * 0.5f);\r\n            }\r\n        }\r\n        else { navHeld = false; nextNavTime = 0f; }\r\n\r\n        bool submitTriggered = false;\r\n        try { submitTriggered = submitAction && submitAction.action.triggered; } catch { }\r\n        if (submitTriggered && selectedNode && centerOnSubmit)\r\n            CenterOnNodeImmediate(selectedNode); // snap on submit\r\n\r\n        // --- Zoom input (does NOT affect pan anymore) ---\r\n        float zDelta = 0f;\r\n        try\r\n        {\r\n            if (zoomAction && zoomAction.action.enabled)\r\n            {\r\n                var controlType = zoomAction.action.expectedControlType;\r\n                if (controlType == \"Vector2\")\r\n                {\r\n                    Vector2 v = zoomAction.action.ReadValue<Vector2>();\r\n                    if (Mathf.Abs(v.y) > 0.01f) zDelta = Mathf.Sign(v.y) * zoomStep;\r\n                }\r\n                else // float\r\n                {\r\n                    float f = zoomAction.action.ReadValue<float>();\r\n                    if (Mathf.Abs(f) > 0.01f) zDelta = Mathf.Sign(f) * zoomStep;\r\n                }\r\n            }\r\n        }\r\n        catch { /* ignore bad bindings */ }\r\n\r\n        if (Mathf.Abs(zDelta) > 0f) ZoomDelta(zDelta);\r\n\r\n        // --- Smooth follow (keep selected centered) ---\r\n        if (keepSelectedCentered)\r\n            FollowSelected(Time.unscaledDeltaTime);\r\n    }\r\n\r\n    // Smoothly pan so the selected node stays at the view center\r\n    private void FollowSelected(float dt)\r\n    {\r\n        if (!ContentRect || !selectedNode || !selectedNode.Rect) return;\r\n        if (disableFollowWhileDragging && isDraggingNode) return;\r\n\r\n        Vector2 targetPan = -selectedNode.Rect.anchoredPosition; // perfect center\r\n        Vector2 currentPan = ContentRect.anchoredPosition;\r\n\r\n        // Dead zone: if we’re already close, don’t thrash\r\n        if ((currentPan - targetPan).sqrMagnitude <= panDeadZone * panDeadZone) return;\r\n\r\n        // SmoothDamp toward target\r\n        Vector2 newPan = Vector2.SmoothDamp(currentPan, targetPan, ref panVelocity, Mathf.Max(0.0001f, panDampTime), Mathf.Infinity, dt);\r\n        ContentRect.anchoredPosition = newPan;\r\n        SaveSystem.Instance?.SetBoardPan(newPan);\r\n    }\r\n\r\n    // ---------- Zoom (no centering side-effects) ----------\r\n    public void ZoomDelta(float delta)\r\n    {\r\n        if (!ContentRect) return;\r\n\r\n        float oldZ = CurrentZoom;\r\n        float newZ = Mathf.Clamp(oldZ + delta, minZoom, maxZoom);\r\n        if (Mathf.Approximately(newZ, oldZ)) return;\r\n\r\n        ContentRect.localScale = Vector3.one * newZ;\r\n        SaveSystem.Instance?.SetBoardZoom(newZ);\r\n    }\r\n\r\n    public void SetZoom(float zoom)\r\n    {\r\n        if (!ContentRect) return;\r\n        float z = Mathf.Clamp(zoom, minZoom, maxZoom);\r\n        ContentRect.localScale = Vector3.one * z;\r\n        SaveSystem.Instance?.SetBoardZoom(z);\r\n    }\r\n\r\n    // ---------- Selection helpers ----------\r\n    private void AutoSelectClosestToCenter()\r\n    {\r\n        if (nodes.Count == 0) { ClearSelection(); return; }\r\n        float best = float.MaxValue; ClueNode bestNode = null;\r\n        foreach (var kv in nodes)\r\n        {\r\n            var n = kv.Value; if (!n || !n.Rect) continue;\r\n            float d2 = n.Rect.anchoredPosition.sqrMagnitude;\r\n            if (d2 < best) { best = d2; bestNode = n; }\r\n        }\r\n        if (bestNode) SelectNodeInternal(bestNode);\r\n    }\r\n    private void SelectNodeInternal(ClueNode node)\r\n    {\r\n        if (selectedNode == node) return;\r\n        if (selectedNode) selectedNode.Rect.localScale = Vector3.one;\r\n\r\n        selectedNode = node; selectedGuid = node ? node.ClueGuid : null;\r\n\r\n        if (selectedNode)\r\n        {\r\n            selectedNode.Rect.localScale = Vector3.one * selectedScale;\r\n            selectedNode.Rect.SetAsLastSibling();\r\n        }\r\n\r\n        // reset follow velocity so the new target starts fresh (no overshoot)\r\n        panVelocity = Vector2.zero;\r\n    }\r\n    private void ClearSelection()\r\n    {\r\n        if (selectedNode) selectedNode.Rect.localScale = Vector3.one;\r\n        selectedNode = null; selectedGuid = null;\r\n    }\r\n    private bool MoveSelectionInDirection(Vector2 dir)\r\n    {\r\n        if (!selectedNode) { AutoSelectClosestToCenter(); return selectedNode != null; }\r\n\r\n        var from = selectedNode.Rect.anchoredPosition;\r\n        string bestGuid = null;\r\n        float bestScore = float.MaxValue;\r\n        foreach (var kv in nodes)\r\n        {\r\n            var n = kv.Value; if (!n || n == selectedNode) continue;\r\n            Vector2 to = n.Rect.anchoredPosition - from;\r\n            float dist = to.magnitude; if (dist < minHopDistance) continue;\r\n            Vector2 nd = to / dist;\r\n            float dot = Vector2.Dot(nd, dir);\r\n            if (dot < cosCone) continue;\r\n            float angleCost = 1f - dot;\r\n            float distCost = dist * 0.0015f;\r\n            float score = angleCost * 1.25f + distCost;\r\n            if (score < bestScore) { bestScore = score; bestGuid = kv.Key; }\r\n        }\r\n        if (bestGuid != null && nodes.TryGetValue(bestGuid, out var bestNode))\r\n        { SelectNodeInternal(bestNode); return true; }\r\n        return false;\r\n    }\r\n    private void CenterOnNodeImmediate(ClueNode node)\r\n    {\r\n        if (!node || !node.Rect || !ContentRect) return;\r\n        ContentRect.anchoredPosition = -node.Rect.anchoredPosition;\r\n        panVelocity = Vector2.zero; // stop motion\r\n        SaveSystem.Instance?.SetBoardPan(ContentRect.anchoredPosition);\r\n    }\r\n\r\n    // ---------- Auto-link logic ----------\r\n    private void BuildAutoLinksTouching(string guid)\r\n    {\r\n        if (!nodes.ContainsKey(guid)) return;\r\n\r\n        var aData = nodes[guid].Data;\r\n        if (aData?.relatedClueGuids != null)\r\n            foreach (var otherGuid in aData.relatedClueGuids)\r\n                EnsureLineWithStyle(guid, otherGuid);\r\n\r\n        foreach (var kv in nodes)\r\n        {\r\n            var otherData = kv.Value.Data;\r\n            if (otherData?.relatedClueGuids == null) continue;\r\n            if (otherData.relatedClueGuids.Contains(guid))\r\n                EnsureLineWithStyle(kv.Key, guid);\r\n        }\r\n    }\r\n\r\n    private void RebuildAllAutoLinks()\r\n    {\r\n        foreach (var l in lines.Values) if (l) Destroy(l.gameObject);\r\n        lines.Clear();\r\n\r\n        foreach (var a in nodes)\r\n        {\r\n            var aData = a.Value.Data;\r\n            if (aData?.relatedClueGuids == null) continue;\r\n            foreach (var bGuid in aData.relatedClueGuids)\r\n                EnsureLineWithStyle(a.Key, bGuid);\r\n        }\r\n        foreach (var b in nodes)\r\n        {\r\n            var bData = b.Value.Data;\r\n            if (bData?.relatedClueGuids == null) continue;\r\n            foreach (var aGuid in bData.relatedClueGuids)\r\n                EnsureLineWithStyle(aGuid, b.Key);\r\n        }\r\n    }\r\n\r\n    private (string, string) PairKey(string a, string b)\r\n    {\r\n        if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b)) return default;\r\n        return string.CompareOrdinal(a, b) <= 0 ? (a, b) : (b, a);\r\n    }\r\n\r\n    private void EnsureLineWithStyle(string aGuid, string bGuid)\r\n    {\r\n        if (string.IsNullOrEmpty(aGuid) || string.IsNullOrEmpty(bGuid)) return;\r\n        if (aGuid == bGuid) return;\r\n        if (!nodes.ContainsKey(aGuid) || !nodes.ContainsKey(bGuid)) return;\r\n\r\n        bool confirmed = SaveSystem.Instance != null && SaveSystem.Instance.IsLinkConfirmed(aGuid, bGuid);\r\n\r\n        var key = PairKey(aGuid, bGuid);\r\n        if (lines.TryGetValue(key, out var existing))\r\n        {\r\n            if (confirmed) { if (existing) Destroy(existing.gameObject); lines.Remove(key); }\r\n            else return;\r\n        }\r\n\r\n        if (!linePrefab) { Debug.LogWarning(\"[CognitionBoard] No linePrefab assigned; cannot draw auto-links.\"); return; }\r\n\r\n        var aNode = nodes[key.Item1];\r\n        var bNode = nodes[key.Item2];\r\n        var aAnchor = aNode.LineAnchor ? aNode.LineAnchor : aNode.Rect;\r\n        var bAnchor = bNode.LineAnchor ? bNode.LineAnchor : bNode.Rect;\r\n\r\n        var line = Instantiate(linePrefab, linesLayer);\r\n        if (confirmed) line.Initialize(aAnchor, bAnchor, confirmedColor, confirmedWidth);\r\n        else           line.Initialize(aAnchor, bAnchor, suggestedColor, suggestedWidth);\r\n\r\n        // Decide which end to grow from based on discovery order (older -> newer)\r\n        int ia = SaveSystem.Instance ? SaveSystem.Instance.GetDiscoveryIndex(key.Item1) : int.MaxValue;\r\n        int ib = SaveSystem.Instance ? SaveSystem.Instance.GetDiscoveryIndex(key.Item2) : int.MaxValue;\r\n        bool fromA = ia <= ib;\r\n        line.SetGrowFrom(fromA);\r\n\r\n        if (!gameObject.activeInHierarchy && playRevealOnOpen)\r\n        {\r\n            line.SetReveal(0f);\r\n            if (pendingLineSet.Add(key))\r\n                pendingLineReveals.Add(key); // keep append order\r\n        }\r\n        else\r\n        {\r\n            line.SetReveal(1f);\r\n        }\r\n\r\n        lines[key] = line;\r\n    }\r\n\r\n    // Convenience wrappers\r\n    public void AddSuggestedConnectionsFor(string guid) => BuildAutoLinksTouching(guid);\r\n    public void BuildAllAutoConnections() => RebuildAllAutoLinks();\r\n    public void RestoreConnectionsFromSave() => RebuildAllAutoLinks();\r\n\r\n    // ---------- Reveal sequence on open ----------\r\n    private System.Collections.IEnumerator PlayOpenRevealSequence()\r\n    {\r\n        // 1) Pop nodes in discovery order\r\n        var order = SaveSystem.Instance ? SaveSystem.Instance.GetDiscoveryOrder() : null;\r\n        if (order != null && order.Count > 0 && pendingNodePops.Count > 0)\r\n        {\r\n            for (int i = 0; i < order.Count; i++)\r\n            {\r\n                string guid = order[i];\r\n                if (!pendingNodePops.Contains(guid)) continue;\r\n                if (!nodes.TryGetValue(guid, out var node) || !node || !node.Rect) continue;\r\n\r\n                // Animate scale 0 -> 1\r\n                float t = 0f;\r\n                while (t < 1f)\r\n                {\r\n                    t += Time.unscaledDeltaTime / Mathf.Max(0.01f, nodePopDuration);\r\n                    float s = Mathf.SmoothStep(0f, 1f, t);\r\n                    node.Rect.localScale = new Vector3(s, s, 1f);\r\n                    yield return null;\r\n                }\r\n                node.Rect.localScale = Vector3.one;\r\n\r\n                // small stagger\r\n                float end = Time.unscaledTime + nodePopStagger;\r\n                while (Time.unscaledTime < end) yield return null;\r\n            }\r\n        }\r\n        pendingNodePops.Clear();\r\n\r\n        // 2) Reveal lines, oldest->newest (by newer endpoint’s discovery index)\r\n        if (pendingLineReveals.Count > 0)\r\n        {\r\n            pendingLineReveals.Sort((p, q) =>\r\n            {\r\n                int pa = SaveSystem.Instance ? SaveSystem.Instance.GetDiscoveryIndex(p.Item1) : int.MaxValue;\r\n                int pb = SaveSystem.Instance ? SaveSystem.Instance.GetDiscoveryIndex(p.Item2) : int.MaxValue;\r\n                int qa = SaveSystem.Instance ? SaveSystem.Instance.GetDiscoveryIndex(q.Item1) : int.MaxValue;\r\n                int qb = SaveSystem.Instance ? SaveSystem.Instance.GetDiscoveryIndex(q.Item2) : int.MaxValue;\r\n\r\n                int pKey = Mathf.Max(pa, pb);\r\n                int qKey = Mathf.Max(qa, qb);\r\n                return pKey.CompareTo(qKey);\r\n            });\r\n\r\n            foreach (var key in pendingLineReveals)\r\n            {\r\n                if (!lines.TryGetValue(key, out var line) || line == null) continue;\r\n\r\n                float t = 0f;\r\n                while (t < 1f)\r\n                {\r\n                    t += Time.unscaledDeltaTime / Mathf.Max(0.01f, revealDurationPerLine);\r\n                    line.SetReveal(Mathf.SmoothStep(0f, 1f, t));\r\n                    yield return null;\r\n                }\r\n                line.SetReveal(1f);\r\n\r\n                float end = Time.unscaledTime + revealStagger;\r\n                while (Time.unscaledTime < end) yield return null;\r\n            }\r\n        }\r\n\r\n        pendingLineReveals.Clear();\r\n        pendingLineSet.Clear();\r\n    }\r\n\r\n    public void ClearAll()\r\n    {\r\n        // Destroy nodes\r\n        foreach (var kv in nodes)\r\n            if (kv.Value) Destroy(kv.Value.gameObject);\r\n        nodes.Clear();\r\n\r\n        // Destroy lines\r\n        foreach (var kv in lines)\r\n            if (kv.Value) Destroy(kv.Value.gameObject);\r\n        lines.Clear();\r\n\r\n        // Reset pan/zoom\r\n        if (ContentRect)\r\n        {\r\n            ContentRect.localScale = Vector3.one;\r\n            ContentRect.anchoredPosition = Vector2.zero;\r\n        }\r\n\r\n        // Persist the reset layout\r\n        SaveSystem.Instance?.SetBoardZoom(1f);\r\n        SaveSystem.Instance?.SetBoardPan(Vector2.zero);\r\n    }\r\n\r\n    // ---------- Placement helpers ----------\r\n    private Vector2 GetViewCenterLocal()\r\n    {\r\n        // If we know the viewport, convert its center to content-local space.\r\n        if (viewportRect && ContentRect && viewportRect.gameObject.activeInHierarchy)\r\n        {\r\n            var vpWorld = viewportRect.TransformPoint(viewportRect.rect.center);\r\n            Vector2 local;\r\n            RectTransformUtility.ScreenPointToLocalPointInRectangle(\r\n                ContentRect, RectTransformUtility.WorldToScreenPoint(null, vpWorld), null, out local);\r\n            return local;\r\n        }\r\n        // Fallback: content pan; view center ≈ -pan\r\n        return -ContentRect.anchoredPosition;\r\n    }\r\n\r\n    private bool IsFarEnoughFromOthers(Vector2 p, float minDist)\r\n    {\r\n        float minSqr = minDist * minDist;\r\n        foreach (var kv in nodes)\r\n        {\r\n            var n = kv.Value;\r\n            if (!n || !n.Rect) continue;\r\n            var d = (n.Rect.anchoredPosition - p).sqrMagnitude;\r\n            if (d < minSqr) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private Vector2 FindFreeSpot(Vector2 seed, float minDist)\r\n    {\r\n        float r = Mathf.Max(0f, spawnRadiusStart);\r\n        var rand = new System.Random((int)(Time.realtimeSinceStartup * 1000f));\r\n\r\n        while (r <= spawnRadiusMax)\r\n        {\r\n            int samples = Mathf.Clamp(Mathf.CeilToInt(2f * Mathf.PI * r / Mathf.Max(1f, minDist)), 8, 48);\r\n            for (int i = 0; i < samples; i++)\r\n            {\r\n                float t = (i + (float)rand.NextDouble() * 0.35f) / samples;\r\n                float ang = t * Mathf.PI * 2f;\r\n                var p = seed + new Vector2(Mathf.Cos(ang), Mathf.Sin(ang)) * r;\r\n                if (IsFarEnoughFromOthers(p, minDist)) return p;\r\n            }\r\n            r += Mathf.Max(8f, spawnRadiusStep);\r\n        }\r\n        return seed;\r\n    }\r\n\r\n    private bool TryGetExistingRelatedCentroid(ClueData data, out Vector2 centroid)\r\n    {\r\n        centroid = Vector2.zero;\r\n        if (data?.relatedClueGuids == null || data.relatedClueGuids.Count == 0) return false;\r\n\r\n        int count = 0;\r\n        foreach (var gid in data.relatedClueGuids)\r\n        {\r\n            if (string.IsNullOrEmpty(gid)) continue;\r\n            if (nodes.TryGetValue(gid, out var n) && n && n.Rect)\r\n            {\r\n                centroid += n.Rect.anchoredPosition;\r\n                count++;\r\n            }\r\n        }\r\n        if (count == 0) return false;\r\n        centroid /= count;\r\n        return true;\r\n    }\r\n\r\n    private Vector2 ClampWithinRelatedMax(Vector2 desired, Vector2 centroid, float maxDist)\r\n    {\r\n        var delta = desired - centroid;\r\n        float d = delta.magnitude;\r\n        if (d <= maxDist || d <= Mathf.Epsilon) return desired;\r\n        return centroid + delta / d * maxDist;\r\n    }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "contentRect",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "nodePrefab",
                    "type": "ClueNode",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "linePrefab",
                    "type": "ConnectionLineUI",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "suggestedColor",
                    "type": "UnityEngine.Color",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "suggestedWidth",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "confirmedColor",
                    "type": "UnityEngine.Color",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "confirmedWidth",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "playRevealOnOpen",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "revealDurationPerLine",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "revealStagger",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "nodePopDuration",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "nodePopStagger",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "navigateAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "submitAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "zoomAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "navDeadZone",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "navFirstDelay",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "navRepeat",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "dirConeDegrees",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "minHopDistance",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "selectedScale",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "centerOnSubmit",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "viewportRect",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "minNodeSpacing",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "relatedMaxDistance",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "spawnRadiusStart",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "spawnRadiusStep",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "spawnRadiusMax",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "minZoom",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "maxZoom",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "zoomStep",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "keepSelectedCentered",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "panDampTime",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "panDeadZone",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "disableFollowWhileDragging",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "CognitionBoard"
            ]
        },
        {
            "kind": 0,
            "className": "ConnectionLine",
            "namespace": "",
            "fullName": "ConnectionLine",
            "filePath": "Assets/Scripts/Draft UI Scripts/ConnectionLine.cs",
            "guid": "3ab840b038b1ecc4aa6c4eb8a7a106a4",
            "source": "// ConnectionLine.cs\r\nusing UnityEngine;\r\n\r\n[RequireComponent(typeof(LineRenderer))]\r\npublic class ConnectionLine : MonoBehaviour\r\n{\r\n    public enum ConnectionState { Suggested, Confirmed }\r\n\r\n    [SerializeField] private LineRenderer lr;\r\n    [SerializeField] private RectTransform a;\r\n    [SerializeField] private RectTransform b;\r\n    [SerializeField] private ConnectionState state;\r\n\r\n    public string AGuid { get; private set; }\r\n    public string BGuid { get; private set; }\r\n    public ConnectionState State => state;\r\n\r\n    private void Awake()\r\n    {\r\n        if (!lr) lr = GetComponent<LineRenderer>();\r\n        lr.positionCount = 2;\r\n        lr.useWorldSpace = false;\r\n        ApplyStyle();\r\n    }\r\n\r\n    public void Initialize(RectTransform aRect, string aGuid, RectTransform bRect, string bGuid, ConnectionState s)\r\n    {\r\n        a = aRect; b = bRect; AGuid = aGuid; BGuid = bGuid; state = s;\r\n        ApplyStyle();\r\n        UpdateLine();\r\n    }\r\n\r\n    public void SetState(ConnectionState s) { state = s; ApplyStyle(); }\r\n\r\n    private void ApplyStyle()\r\n    {\r\n        var color = state == ConnectionState.Confirmed ? Color.green : Color.red;\r\n        lr.startColor = lr.endColor = color;\r\n        var width = state == ConnectionState.Confirmed ? 0.045f : 0.03f;\r\n        lr.startWidth = lr.endWidth = width;\r\n    }\r\n\r\n    private void LateUpdate() { UpdateLine(); }\r\n\r\n    private void UpdateLine()\r\n    {\r\n        if (!a || !b) return;\r\n        lr.SetPosition(0, a.anchoredPosition);\r\n        lr.SetPosition(1, b.anchoredPosition);\r\n    }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "lr",
                    "type": "UnityEngine.LineRenderer",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "a",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "b",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "state",
                    "type": "ConnectionLine+ConnectionState",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "ConnectionLine",
                "ConnectionState"
            ]
        },
        {
            "kind": 0,
            "className": "ConnectionLineUI",
            "namespace": "",
            "fullName": "ConnectionLineUI",
            "filePath": "Assets/Scripts/Draft UI Scripts/ConnectionLineUI.cs",
            "guid": "d6023d701623b2a4ba134224be1e829a",
            "source": "using UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\npublic class ConnectionLineUI : MonoBehaviour\r\n{\r\n    [SerializeField] private RectTransform from;       // A anchor (older or chosen start)\r\n    [SerializeField] private RectTransform to;         // B anchor\r\n    [SerializeField] private RectTransform lineRect;   // this rect (horizontal bar)\r\n    [SerializeField] private Image image;              // Image on this object\r\n    [SerializeField] private RectTransform container;  // parent (Lines layer)\r\n\r\n    [Range(0f, 1f)] public float reveal = 1f;          // 0..1 length\r\n    private bool growFromA = true;                     // NEW: direction of reveal\r\n\r\n    public void Initialize(RectTransform a, RectTransform b, Color color, float width)\r\n    {\r\n        from = a; to = b;\r\n        if (!lineRect)  lineRect  = GetComponent<RectTransform>();\r\n        if (!image)     image     = GetComponent<Image>();\r\n        if (!container) container = (RectTransform)transform.parent;\r\n\r\n        if (image) image.color = color;\r\n        SetThickness(width);\r\n        UpdateLine();\r\n    }\r\n\r\n    public void SetStyle(Color color, float width)\r\n    {\r\n        if (image) image.color = color;\r\n        SetThickness(width);\r\n    }\r\n\r\n    public void SetReveal(float t)\r\n    {\r\n        reveal = Mathf.Clamp01(t);\r\n        UpdateLine();\r\n    }\r\n\r\n    public void SetGrowFrom(bool fromA) => growFromA = fromA; // NEW\r\n\r\n    private void SetThickness(float width)\r\n    {\r\n        if (!lineRect) return;\r\n        var sz = lineRect.sizeDelta;\r\n        sz.y = Mathf.Max(1f, width);\r\n        lineRect.sizeDelta = sz;\r\n    }\r\n\r\n    private void LateUpdate() => UpdateLine();\r\n\r\n    private void UpdateLine()\r\n    {\r\n        if (!from || !to || !lineRect) return;\r\n        if (!container) container = (RectTransform)transform.parent;\r\n        if (!container) return;\r\n\r\n        Vector2 a = WorldCenterToLocal(from);\r\n        Vector2 b = WorldCenterToLocal(to);\r\n        Vector2 delta = b - a;\r\n        float fullLen = delta.magnitude;\r\n        if (fullLen < 0.001f) return;\r\n\r\n        float angle = Mathf.Atan2(delta.y, delta.x) * Mathf.Rad2Deg;\r\n\r\n        Vector2 start, end;\r\n        if (reveal >= 0.999f)\r\n        {\r\n            start = a; end = b;\r\n        }\r\n        else if (growFromA)\r\n        {\r\n            start = a;\r\n            end   = a + delta * Mathf.Clamp01(reveal);\r\n        }\r\n        else\r\n        {\r\n            end   = b;\r\n            start = b - delta * Mathf.Clamp01(reveal);\r\n        }\r\n\r\n        Vector2 mid = (start + end) * 0.5f;\r\n        float len = (end - start).magnitude;\r\n\r\n        lineRect.anchoredPosition = mid;\r\n        var sz = lineRect.sizeDelta;\r\n        sz.x = len;\r\n        lineRect.sizeDelta = sz;\r\n        lineRect.localRotation = Quaternion.Euler(0, 0, angle);\r\n    }\r\n\r\n    private Vector2 WorldCenterToLocal(RectTransform rt)\r\n    {\r\n        Vector3 world = rt.TransformPoint(rt.rect.center);\r\n        return ((RectTransform)transform.parent).InverseTransformPoint(world);\r\n    }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "from",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "to",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "lineRect",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "image",
                    "type": "UnityEngine.UI.Image",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "container",
                    "type": "UnityEngine.RectTransform",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "reveal",
                    "type": "System.Single",
                    "isPublic": true,
                    "hasSerializeField": false
                }
            ],
            "declaredTypes": [
                "ConnectionLineUI"
            ]
        },
        {
            "kind": 0,
            "className": "CutsceneManager",
            "namespace": "",
            "fullName": "CutsceneManager",
            "filePath": "Assets/Scripts/Top-Level Managers/CutsceneManager.cs",
            "guid": "bc03bb09ad51fff4c92041be5975352c",
            "source": "using UnityEngine;\r\nusing UnityEngine.SceneManagement; // Needed for scene loading\r\nusing System; // Needed for Action\r\nusing System.Collections;\r\n\r\npublic class CutsceneManager : MonoBehaviour\r\n{\r\n    // Reference to the player's Animator component\r\n    public Animator playerAnimator;\r\n\r\n    // Duration of the cutscene animation in seconds\r\n    public float cutsceneDuration = 3f;\r\n\r\n    /// <summary>\r\n    /// Starts the cutscene animation and executes the optional callback after completion.\r\n    /// </summary>\r\n    /// <param name=\"onComplete\">An optional Action to invoke after the cutscene ends.</param>\r\n    public void PlayCutscene(Action onComplete = null)\r\n    {\r\n        StartCoroutine(CutsceneSequence(onComplete));\r\n    }\r\n\r\n    /// <summary>\r\n    /// Coroutine that plays the cutscene animation, waits for its duration, then calls callback.\r\n    /// </summary>\r\n    /// <param name=\"onComplete\">Callback to execute after cutscene</param>\r\n    private IEnumerator CutsceneSequence(Action onComplete)\r\n    {\r\n        Debug.Log(\"Cutscene starting...\");\r\n        // Trigger the door opening animation (make sure this trigger exists in your Animator)\r\n        if (playerAnimator != null)\r\n        {\r\n            playerAnimator.SetTrigger(\"PlayDoorCutscene\");\r\n        }\r\n        else\r\n        {\r\n            Debug.LogWarning(\"Player Animator not assigned in CutsceneManager.\");\r\n        }\r\n\r\n        // Wait for the duration of your animation\r\n        yield return new WaitForSeconds(cutsceneDuration);\r\n\r\n        Debug.Log(\"Cutscene ending...\");\r\n        // Call the callback to load the scene or perform other actions\r\n        onComplete?.Invoke();\r\n    }\r\n}",
            "serializedFields": [
                {
                    "name": "playerAnimator",
                    "type": "UnityEngine.Animator",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "cutsceneDuration",
                    "type": "System.Single",
                    "isPublic": true,
                    "hasSerializeField": false
                }
            ],
            "declaredTypes": [
                "CutsceneManager"
            ]
        },
        {
            "kind": 0,
            "className": "DialogueGraphRunner",
            "namespace": "",
            "fullName": "DialogueGraphRunner",
            "filePath": "Assets/Scripts/Dialogue/DialogueGraphRunner.cs",
            "guid": "9fc4bd4bced97f64d93c2ada31fc961e",
            "source": "using System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\n\r\npublic class DialogueGraphRunner : MonoBehaviour\r\n{\r\n    private static DialogueGraphRunner _runner;\r\n    private static DialogueGraphRunner Runner\r\n    {\r\n        get\r\n        {\r\n            if (_runner == null)\r\n            {\r\n                var go = new GameObject(\"DialogueGraphRunner\");\r\n                _runner = go.AddComponent<DialogueGraphRunner>();\r\n                DontDestroyOnLoad(go);\r\n            }\r\n            return _runner;\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// Plays a DialogueGraph via the existing DialogueManager UI.\r\n    /// Returns pickupApproved=true if the player selects a choice with semantic PickupYes anywhere in the flow.\r\n    /// </summary>\r\n    public static void Play(DialogueGraph graph, Action<GraphRunResult> onComplete)\r\n    {\r\n        if (graph == null)\r\n        {\r\n            Debug.LogWarning(\"[DialogueGraphRunner] Graph is null.\");\r\n            onComplete?.Invoke(new GraphRunResult { pickupApproved = false });\r\n            return;\r\n        }\r\n        Runner.StartCoroutine(Runner.RunGraph(graph, onComplete));\r\n    }\r\n\r\n    private IEnumerator RunGraph(DialogueGraph graph, Action<GraphRunResult> onComplete)\r\n    {\r\n        var dm = DialogueManager.Instance;\r\n        if (dm == null)\r\n        {\r\n            Debug.LogError(\"[DialogueGraphRunner] DialogueManager.Instance is null.\");\r\n            onComplete?.Invoke(new GraphRunResult { pickupApproved = false });\r\n            yield break;\r\n        }\r\n\r\n        string cur = graph.startGuid;\r\n        bool pickupApproved = false;\r\n\r\n        while (!string.IsNullOrEmpty(cur))\r\n        {\r\n            DialogueNode node = graph.Get(cur);\r\n            if (node == null)\r\n            {\r\n                Debug.LogWarning($\"[GraphRunner] Node '{cur}' not found. Ending.\");\r\n                break;\r\n            }\r\n\r\n            if (!node.isChoice)\r\n            {\r\n                // TEXT node\r\n                bool done = false;\r\n                dm.StartSequence(\r\n                    new List<DialogueBlock> {\r\n                        new DialogueBlock { type = BlockType.Text, text = node.text }\r\n                    },\r\n                    _ => { done = true; }\r\n                );\r\n                while (!done) yield return null;\r\n\r\n                cur = node.nextGuid; // advance to next (may be null/empty to end)\r\n            }\r\n            else\r\n            {\r\n                // CHOICE node\r\n                string prompt = string.IsNullOrEmpty(node.text) ? \"\" : node.text;\r\n\r\n                var options = new List<string>();\r\n                foreach (var ch in node.choices) options.Add(ch?.label ?? \"Option\");\r\n\r\n                int def = 0;\r\n                if (options.Count > 0)\r\n                    def = Mathf.Clamp(node.defaultChoiceIndex, 0, options.Count - 1);\r\n\r\n                bool done = false;\r\n                SequenceResult result = null;\r\n\r\n                dm.StartSequence(\r\n                    new List<DialogueBlock> {\r\n                        new DialogueBlock {\r\n                            type = BlockType.Choice,\r\n                            prompt = prompt,\r\n                            options = options,\r\n                            defaultIndex = def\r\n                        }\r\n                    },\r\n                    r => { result = r; done = true; }\r\n                );\r\n                while (!done) yield return null;\r\n\r\n                int pickedIndex = Mathf.Clamp(result?.lastChoiceIndex ?? def, 0, Math.Max(0, options.Count - 1));\r\n                var picked = (pickedIndex >= 0 && pickedIndex < node.choices.Count) ? node.choices[pickedIndex] : null;\r\n\r\n                // Map semantics explicitly\r\n                if (picked != null)\r\n                {\r\n                    switch (picked.semantic)\r\n                    {\r\n                        case ChoiceSemantic.PickupYes:\r\n                            pickupApproved = true;\r\n                            break;\r\n                        case ChoiceSemantic.PickupNo:\r\n                            pickupApproved = false;\r\n                            break;\r\n                        case ChoiceSemantic.None:\r\n                        default:\r\n                            // no change\r\n                            break;\r\n\r\n                        // If you still use a legacy PickupYesNo somewhere, uncomment:\r\n                        // case ChoiceSemantic.PickupYesNo:\r\n                        //     pickupApproved = true; // treat as YES by convention\r\n                        //     break;\r\n                    }\r\n                }\r\n\r\n                Debug.Log($\"[GraphRunner] Picked index={pickedIndex} label='{picked?.label}' semantic={picked?.semantic} => pickupApproved={pickupApproved}\");\r\n\r\n                // follow the chosen branch\r\n                cur = picked?.nextGuid;\r\n            }\r\n        }\r\n\r\n        onComplete?.Invoke(new GraphRunResult { pickupApproved = pickupApproved });\r\n    }\r\n}\r\n\r\npublic struct GraphRunResult\r\n{\r\n    public bool pickupApproved;\r\n}\r\n",
            "serializedFields": [],
            "declaredTypes": [
                "DialogueGraphRunner",
                "GraphRunResult"
            ]
        },
        {
            "kind": 0,
            "className": "DialogueManager",
            "namespace": "",
            "fullName": "DialogueManager",
            "filePath": "Assets/Scripts/Dialogue/DialogueManager.cs",
            "guid": "59972c7d1bd5b35428f914cc21e04f4d",
            "source": "using UnityEngine;\r\nusing TMPro;\r\nusing UnityEngine.InputSystem;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\nusing UnityEngine.SceneManagement;\r\n\r\npublic class DialogueManager : MonoBehaviour\r\n{\r\n    public static DialogueManager Instance { get; private set; }\r\n    public static event System.Action<bool> OnDialogActiveChanged;\r\n\r\n    [Header(\"UI\")]\r\n    [SerializeField] private GameObject dialogueUI;\r\n    [SerializeField] private TMP_Text dialogueText;\r\n\r\n    [Header(\"Inputs\")]\r\n    [SerializeField] private InputActionReference submitAction;   // A / UI-Submit\r\n    [SerializeField] private InputActionReference cancelAction;   // B / UI-Cancel\r\n    [SerializeField] private InputActionReference navigateAction; // UI-Navigate (for choices)\r\n\r\n    [Header(\"Actions to disable while dialogue is open\")]\r\n    [SerializeField] private List<InputActionReference> disableWhileOpen = new();\r\n\r\n    [Header(\"Typewriter\")]\r\n    [SerializeField] private float charInterval = 0.02f;\r\n    [SerializeField] private float shortPunctPause = 0.06f;   // , ; : — – ) \\n\r\n    [SerializeField] private float longPunctPause = 0.18f;    // . ! ?\r\n    [SerializeField] private float minShowSeconds = 0.15f;\r\n\r\n    [Header(\"Choice UI Style\")]\r\n    [Tooltip(\"Optional prefab for choice labels. If null, labels are created & styled from dialogueText.\")]\r\n    [SerializeField] private TextMeshProUGUI choiceTextPrefab;\r\n\r\n    [Header(\"Scene Reload / Reset Safety\")]\r\n    [Tooltip(\"On scene load we will auto-hide the dialogue panel and re-enable gameplay actions.\")]\r\n    [SerializeField] private bool autoHideOnSceneLoad = true;\r\n\r\n    [Tooltip(\"Try to auto-bind to a DialogueUIBinder in the scene when opening or resetting.\")]\r\n    [SerializeField] private bool autoFindUIOnOpen = true;\r\n\r\n    // === New fallback settings ===\r\n    [Header(\"Auto-Bind Fallbacks\")]\r\n    [SerializeField] private string fallbackPanelName = \"DialogueUI\";\r\n    [SerializeField] private string fallbackTextName = \"DialogueText\";\r\n    [SerializeField] private string fallbackPanelTag = \"\";\r\n\r\n    // -------- state --------\r\n    private bool isVisible;\r\n    private float shownAt;\r\n    private bool waitForSubmitRelease;\r\n    private readonly List<InputAction> reenableBuffer = new();\r\n\r\n    private Coroutine typingCo;\r\n    private bool isTyping;\r\n    private bool fastForwardRequested;\r\n\r\n    // sequence\r\n    private Coroutine sequenceCo;\r\n    private System.Action<SequenceResult> onSequenceComplete;\r\n\r\n    // choices\r\n    private RectTransform choiceRow;\r\n    private readonly List<TMP_Text> choiceLabels = new();\r\n    private int selectedIndex;\r\n    private int choiceResultIndex = -1;\r\n    private float nextNavTime;\r\n    private const float NAV_REPEAT = 0.15f;\r\n\r\n    private const string SHORT_SET = \",;:—–)\\n\";\r\n    private const string LONG_SET = \".!?\";\r\n\r\n    private void Awake()\r\n    {\r\n        if (Instance && Instance != this) { Destroy(gameObject); return; }\r\n        Instance = this;\r\n        DontDestroyOnLoad(gameObject);\r\n\r\n        if (dialogueUI) dialogueUI.SetActive(false);\r\n        if (dialogueText) DecoupleMaterial(dialogueText);\r\n\r\n        SceneManager.sceneLoaded += OnSceneLoaded;\r\n    }\r\n\r\n    private void OnDestroy()\r\n    {\r\n        if (Instance == this) SceneManager.sceneLoaded -= OnSceneLoaded;\r\n    }\r\n\r\n    private void OnSceneLoaded(Scene _, LoadSceneMode __)\r\n    {\r\n        if (!autoHideOnSceneLoad) return;\r\n        ForceHideAndReset();\r\n    }\r\n\r\n    private void OnEnable()\r\n    {\r\n        if (submitAction?.action != null)\r\n        {\r\n            submitAction.action.started += OnSubmitStarted;\r\n            submitAction.action.performed += OnSubmitPerformed;\r\n            submitAction.action.canceled += OnSubmitCanceled;\r\n            submitAction.action.Enable();\r\n        }\r\n        if (cancelAction?.action != null)\r\n        {\r\n            cancelAction.action.started += OnCancelStarted;\r\n            cancelAction.action.performed += OnCancelPerformed;\r\n            cancelAction.action.Enable();\r\n        }\r\n        if (navigateAction?.action != null) navigateAction.action.Enable();\r\n    }\r\n\r\n    private void OnDisable()\r\n    {\r\n        if (submitAction?.action != null)\r\n        {\r\n            submitAction.action.started -= OnSubmitStarted;\r\n            submitAction.action.performed -= OnSubmitPerformed;\r\n            submitAction.action.canceled -= OnSubmitCanceled;\r\n            submitAction.action.Disable();\r\n        }\r\n        if (cancelAction?.action != null)\r\n        {\r\n            cancelAction.action.started -= OnCancelStarted;\r\n            cancelAction.action.performed -= OnCancelPerformed;\r\n            cancelAction.action.Disable();\r\n        }\r\n        if (navigateAction?.action != null) navigateAction.action.Disable();\r\n\r\n        RestoreBlockedActions();\r\n    }\r\n\r\n    private void Update()\r\n    {\r\n        if (isVisible && IsShowingChoices())\r\n        {\r\n            Vector2 nav = navigateAction ? navigateAction.action.ReadValue<Vector2>() : Vector2.zero;\r\n            float now = Time.unscaledTime;\r\n\r\n            if (nav.x > 0.5f && now >= nextNavTime)\r\n            {\r\n                MoveChoice(+1);\r\n                nextNavTime = now + NAV_REPEAT;\r\n            }\r\n            else if (nav.x < -0.5f && now >= nextNavTime)\r\n            {\r\n                MoveChoice(-1);\r\n                nextNavTime = now + NAV_REPEAT;\r\n            }\r\n            if (Mathf.Abs(nav.x) < 0.25f) nextNavTime = 0f;\r\n        }\r\n    }\r\n\r\n    // -------- Public API --------\r\n    public void ShowDialogue(string message)\r\n    {\r\n        StartSequence(new List<DialogueBlock> {\r\n            new DialogueBlock { type = BlockType.Text, text = message }\r\n        }, null);\r\n    }\r\n\r\n    public void StartSequence(List<DialogueBlock> blocks, System.Action<SequenceResult> onComplete)\r\n    {\r\n        if (isVisible) return;\r\n        if (blocks == null || blocks.Count == 0) return;\r\n        if (sequenceCo != null) StopCoroutine(sequenceCo);\r\n        onSequenceComplete = onComplete;\r\n        sequenceCo = StartCoroutine(RunSequence(blocks));\r\n    }\r\n\r\n    public bool IsActive() => isVisible;\r\n    public bool IsDialogueActive() => isVisible;\r\n    public void Hide() => ClosePanel();\r\n\r\n    public void ForceHideAndReset()\r\n    {\r\n        if (autoFindUIOnOpen) TryAutoFindUI();\r\n\r\n        if (typingCo != null) { StopCoroutine(typingCo); typingCo = null; }\r\n        isTyping = false;\r\n        fastForwardRequested = false;\r\n        waitForSubmitRelease = false;\r\n\r\n        ClearChoices();\r\n\r\n        if (dialogueUI) dialogueUI.SetActive(false);\r\n        if (dialogueText) dialogueText.text = string.Empty;\r\n\r\n        isVisible = false;\r\n\r\n        SafeEnableBlockedActions();\r\n        OnDialogActiveChanged?.Invoke(false);\r\n\r\n        // NEW: ensure UI input map is ready after reset\r\n        EnsureDialogueInputsEnabled();\r\n    }\r\n\r\n    public void BindUI(GameObject panel, TMP_Text text)\r\n    {\r\n        dialogueUI = panel;\r\n        dialogueText = text;\r\n        DecoupleMaterial(dialogueText);\r\n        if (dialogueUI) dialogueUI.SetActive(false);\r\n    }\r\n\r\n    // -------- Sequence driver --------\r\n    private IEnumerator RunSequence(List<DialogueBlock> blocks)\r\n    {\r\n        OpenPanel();\r\n\r\n        SequenceResult result = new SequenceResult();\r\n\r\n        for (int i = 0; i < blocks.Count; i++)\r\n        {\r\n            var b = blocks[i];\r\n\r\n            if (b.type == BlockType.Text)\r\n            {\r\n                yield return ShowTextAndWait(b.text);\r\n            }\r\n            else\r\n            {\r\n                yield return ShowChoiceAndWait(b);\r\n                result.lastChoice = b;\r\n                result.lastChoiceIndex = choiceResultIndex;\r\n                if (b.options != null &&\r\n                    choiceResultIndex >= 0 &&\r\n                    choiceResultIndex < b.options.Count)\r\n                    result.lastChoiceText = b.options[choiceResultIndex];\r\n            }\r\n        }\r\n\r\n        ClosePanel();\r\n        onSequenceComplete?.Invoke(result);\r\n        onSequenceComplete = null;\r\n        sequenceCo = null;\r\n    }\r\n\r\n    private IEnumerator ShowTextAndWait(string message)\r\n    {\r\n        PrepareForText();\r\n\r\n        if (typingCo != null) StopCoroutine(typingCo);\r\n        typingCo = StartCoroutine(Typewriter(message));\r\n        while (isTyping) yield return null;\r\n\r\n        yield return WaitForClosePress();\r\n    }\r\n\r\n    private IEnumerator ShowChoiceAndWait(DialogueBlock block)\r\n    {\r\n        choiceResultIndex = -1;\r\n        string prompt = block.prompt ?? \"\";\r\n        PrepareForText();\r\n\r\n        if (typingCo != null) StopCoroutine(typingCo);\r\n        typingCo = StartCoroutine(Typewriter(prompt));\r\n        while (isTyping) yield return null;\r\n\r\n        BuildChoices(block.options, block.defaultIndex);\r\n\r\n        bool picked = false;\r\n        while (!picked)\r\n        {\r\n            if (submitAction != null && submitAction.action.triggered)\r\n            {\r\n                choiceResultIndex = selectedIndex;\r\n                picked = true;\r\n            }\r\n            else if (cancelAction != null && cancelAction.action.triggered)\r\n            {\r\n                choiceResultIndex = Mathf.Clamp(block.defaultIndex, 0, (block.options?.Count ?? 1) - 1);\r\n                picked = true;\r\n            }\r\n            yield return null;\r\n        }\r\n\r\n        ClearChoices();\r\n        yield return null;\r\n    }\r\n\r\n    // -------- Open/Close panel --------\r\n    private void OpenPanel()\r\n    {\r\n        if (autoFindUIOnOpen) TryAutoFindUI();\r\n        if (!dialogueUI || !dialogueText)\r\n        {\r\n            Debug.LogError(\"[DialogueManager] Cannot open — UI not bound.\");\r\n            isVisible = false;\r\n            return;\r\n        }\r\n\r\n        EnsureDialogueInputsEnabled();\r\n\r\n        dialogueText.text = string.Empty;\r\n\r\n        // NEW: force visible/interactive\r\n        var cg = dialogueUI.GetComponent<CanvasGroup>();\r\n        if (!cg) cg = dialogueUI.AddComponent<CanvasGroup>();\r\n        cg.alpha = 1f;\r\n        cg.interactable = true;\r\n        cg.blocksRaycasts = true;\r\n        var canvas = dialogueUI.GetComponentInParent<Canvas>(true);\r\n        if (canvas) canvas.enabled = true;\r\n\r\n        dialogueUI.SetActive(true);\r\n\r\n        isVisible = true;\r\n        shownAt = Time.unscaledTime;\r\n        waitForSubmitRelease = true;\r\n        fastForwardRequested = false;\r\n\r\n        BlockActions();\r\n        OnDialogActiveChanged?.Invoke(true);\r\n    }\r\n\r\n    private void ClosePanel()\r\n    {\r\n        if (typingCo != null) { StopCoroutine(typingCo); typingCo = null; }\r\n        isTyping = false;\r\n        fastForwardRequested = false;\r\n\r\n        ClearChoices();\r\n\r\n        if (dialogueUI) dialogueUI.SetActive(false);\r\n        isVisible = false;\r\n\r\n        RestoreBlockedActions();\r\n        OnDialogActiveChanged?.Invoke(false);\r\n    }\r\n\r\n    // -------- Input handlers --------\r\n    private void OnSubmitStarted(InputAction.CallbackContext _)\r\n    {\r\n        if (!isVisible) return;\r\n        if (isTyping)\r\n        {\r\n            if (waitForSubmitRelease) return;\r\n            fastForwardRequested = true;\r\n            return;\r\n        }\r\n        if (waitForSubmitRelease) return;\r\n        if (!IsShowingChoices()) TryCloseBubble();\r\n    }\r\n    private void OnSubmitPerformed(InputAction.CallbackContext _) { }\r\n    private void OnSubmitCanceled(InputAction.CallbackContext _) { if (isVisible) waitForSubmitRelease = false; }\r\n\r\n    private void OnCancelStarted(InputAction.CallbackContext _)\r\n    {\r\n        if (!isVisible) return;\r\n        if (isTyping)\r\n        {\r\n            if (waitForSubmitRelease) return;\r\n            fastForwardRequested = true;\r\n            return;\r\n        }\r\n        if (waitForSubmitRelease) return;\r\n        if (!IsShowingChoices()) TryCloseBubble();\r\n    }\r\n    private void OnCancelPerformed(InputAction.CallbackContext _) { }\r\n\r\n    private void TryCloseBubble()\r\n    {\r\n        if (Time.unscaledTime - shownAt < minShowSeconds) return;\r\n    }\r\n\r\n    private IEnumerator WaitForClosePress()\r\n    {\r\n        float earliest = Time.unscaledTime + minShowSeconds;\r\n        while (Time.unscaledTime < earliest) yield return null;\r\n\r\n        // release guard\r\n        while (waitForSubmitRelease) yield return null;\r\n\r\n        bool pressed = false;\r\n        while (!pressed)\r\n        {\r\n            if ((submitAction != null && submitAction.action.triggered) ||\r\n                (cancelAction != null && cancelAction.action.triggered))\r\n                pressed = true;\r\n            yield return null;\r\n        }\r\n    }\r\n\r\n    private IEnumerator Typewriter(string msg)\r\n    {\r\n        if (isTyping) yield break; // guard\r\n        isTyping = true;\r\n        fastForwardRequested = false;\r\n        if (dialogueText) dialogueText.text = string.Empty;\r\n\r\n        var sb = new StringBuilder(msg.Length + 16);\r\n        int i = 0;\r\n\r\n        while (i < msg.Length)\r\n        {\r\n            char c = msg[i];\r\n\r\n            if (c == '<')\r\n            {\r\n                int close = msg.IndexOf('>', i);\r\n                if (close >= 0)\r\n                {\r\n                    sb.Append(msg, i, close - i + 1);\r\n                    if (dialogueText) dialogueText.text = sb.ToString();\r\n                    i = close + 1;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            if (c == '.' && i + 2 < msg.Length && msg[i + 1] == '.' && msg[i + 2] == '.')\r\n            {\r\n                sb.Append(\"...\");\r\n                if (dialogueText) dialogueText.text = sb.ToString();\r\n                i += 3;\r\n                if (!fastForwardRequested) yield return PauseRealtime(longPunctPause);\r\n                continue;\r\n            }\r\n\r\n            sb.Append(c);\r\n            if (dialogueText) dialogueText.text = sb.ToString();\r\n            i++;\r\n\r\n            if (!fastForwardRequested && charInterval > 0f)\r\n                yield return new WaitForSecondsRealtime(charInterval);\r\n\r\n            if (!fastForwardRequested)\r\n            {\r\n                if (c == '\\n') yield return PauseRealtime(shortPunctPause);\r\n                else if (LONG_SET.IndexOf(c) >= 0) yield return PauseRealtime(longPunctPause);\r\n                else if (SHORT_SET.IndexOf(c) >= 0) yield return PauseRealtime(shortPunctPause);\r\n            }\r\n        }\r\n\r\n        isTyping = false;\r\n        typingCo = null;\r\n        fastForwardRequested = false;\r\n    }\r\n\r\n    private IEnumerator PauseRealtime(float seconds)\r\n    {\r\n        if (seconds <= 0f) yield break;\r\n        float end = Time.unscaledTime + seconds;\r\n        while (Time.unscaledTime < end)\r\n        {\r\n            if (fastForwardRequested) yield break;\r\n            yield return null;\r\n        }\r\n    }\r\n\r\n    private void PrepareForText()\r\n    {\r\n        if (dialogueText) dialogueText.text = string.Empty;\r\n        shownAt = Time.unscaledTime;\r\n        waitForSubmitRelease = true;\r\n        fastForwardRequested = false;\r\n        ClearChoices();\r\n        StartCoroutine(ReleaseGuard());\r\n    }\r\n\r\n    private IEnumerator ReleaseGuard()\r\n    {\r\n        float end = Time.unscaledTime + 0.25f;\r\n        while (waitForSubmitRelease && Time.unscaledTime < end) yield return null;\r\n        waitForSubmitRelease = false;\r\n    }\r\n\r\n    private bool IsShowingChoices() => choiceRow != null && choiceRow.gameObject.activeSelf;\r\n\r\n    private void BuildChoices(List<string> options, int startIndex)\r\n    {\r\n        if (options == null || options.Count == 0) options = new List<string> { \"OK\" };\r\n\r\n        if (choiceRow == null)\r\n        {\r\n            if (!dialogueUI) return;\r\n            var rowGO = new GameObject(\"ChoiceRow\", typeof(RectTransform));\r\n            choiceRow = rowGO.GetComponent<RectTransform>();\r\n            choiceRow.SetParent(dialogueUI.transform, false);\r\n            choiceRow.anchorMin = choiceRow.anchorMax = new Vector2(0.5f, 0);\r\n            choiceRow.pivot = new Vector2(0.5f, 0);\r\n            choiceRow.anchoredPosition = new Vector2(0, 20);\r\n            choiceRow.sizeDelta = new Vector2(600, 40);\r\n        }\r\n\r\n        foreach (var t in choiceLabels) if (t) Destroy(t.gameObject);\r\n        choiceLabels.Clear();\r\n\r\n        float spacing = 180f;\r\n        float startX = -spacing * (options.Count - 1) * 0.5f;\r\n\r\n        for (int i = 0; i < options.Count; i++)\r\n        {\r\n            TextMeshProUGUI tm;\r\n            if (choiceTextPrefab != null)\r\n                tm = Instantiate(choiceTextPrefab, choiceRow);\r\n            else\r\n            {\r\n                var go = new GameObject(\"Opt_\" + i, typeof(RectTransform), typeof(TextMeshProUGUI));\r\n                tm = go.GetComponent<TextMeshProUGUI>();\r\n                tm.rectTransform.SetParent(choiceRow, false);\r\n                CopyTextStyle(dialogueText, tm);\r\n            }\r\n\r\n            ApplyDialogueMaterial(tm);\r\n\r\n            var r = tm.rectTransform;\r\n            r.anchorMin = r.anchorMax = new Vector2(0.5f, 0.5f);\r\n            r.pivot = new Vector2(0.5f, 0.5f);\r\n            r.sizeDelta = new Vector2(160, 40);\r\n            r.anchoredPosition = new Vector2(startX + spacing * i, 0);\r\n\r\n            tm.alignment = TextAlignmentOptions.Center;\r\n            tm.text = options[i] ?? \"\";\r\n\r\n            choiceLabels.Add(tm);\r\n        }\r\n\r\n        choiceRow.gameObject.SetActive(true);\r\n        selectedIndex = Mathf.Clamp(startIndex, 0, options.Count - 1);\r\n        RefreshChoiceVisuals();\r\n        nextNavTime = 0f;\r\n    }\r\n\r\n    private void ClearChoices()\r\n    {\r\n        if (choiceRow != null) choiceRow.gameObject.SetActive(false);\r\n    }\r\n\r\n    private void MoveChoice(int delta)\r\n    {\r\n        if (!IsShowingChoices()) return;\r\n        selectedIndex = Mathf.Clamp(selectedIndex + delta, 0, choiceLabels.Count - 1);\r\n        RefreshChoiceVisuals();\r\n    }\r\n\r\n    private void RefreshChoiceVisuals()\r\n    {\r\n        for (int i = 0; i < choiceLabels.Count; i++)\r\n        {\r\n            var tm = choiceLabels[i];\r\n            if (!tm) continue;\r\n            string raw = tm.text.Replace(\"<b>\", \"\").Replace(\"</b>\", \"\").Replace(\"<u>\", \"\").Replace(\"</u>\", \"\");\r\n            tm.text = (i == selectedIndex) ? $\"<b><u>{raw}</u></b>\" : raw;\r\n        }\r\n    }\r\n\r\n    private void BlockActions()\r\n    {\r\n        reenableBuffer.Clear();\r\n\r\n        foreach (var aref in disableWhileOpen)\r\n        {\r\n            var action = aref?.action;\r\n            if (action == null) continue;\r\n            if (submitAction != null && action == submitAction.action) continue;\r\n            if (cancelAction != null && action == cancelAction.action) continue;\r\n            if (navigateAction != null && action == navigateAction.action) continue;\r\n\r\n            if (action.enabled)\r\n            {\r\n                action.Disable();\r\n                reenableBuffer.Add(action);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void RestoreBlockedActions()\r\n    {\r\n        foreach (var a in reenableBuffer)\r\n            if (a != null && !a.enabled) a.Enable();\r\n        reenableBuffer.Clear();\r\n    }\r\n\r\n    private void SafeEnableBlockedActions()\r\n    {\r\n        foreach (var aref in disableWhileOpen)\r\n        {\r\n            var a = aref?.action;\r\n            try { if (a != null && !a.enabled) a.Enable(); } catch { }\r\n        }\r\n    }\r\n\r\n    private void EnsureDialogueInputsEnabled()\r\n    {\r\n        try { submitAction?.action?.Enable(); } catch { }\r\n        try { cancelAction?.action?.Enable(); } catch { }\r\n        try { navigateAction?.action?.Enable(); } catch { }\r\n\r\n        try { submitAction?.action?.actionMap?.Enable(); } catch { }\r\n        try { cancelAction?.action?.actionMap?.Enable(); } catch { }\r\n        try { navigateAction?.action?.actionMap?.Enable(); } catch { }\r\n    }\r\n\r\n    private void TryAutoFindUI()\r\n    {\r\n        if (dialogueUI && dialogueText) return;\r\n\r\n        var binder = FindFirstObjectByType<DialogueUIBinder>(FindObjectsInactive.Include);\r\nif (binder != null)\r\n{\r\n    binder.TryBindNow(); // call it (doesn't return anything)\r\n    if (dialogueUI && dialogueText)\r\n    {\r\n        DecoupleMaterial(dialogueText);\r\n        return;\r\n    }\r\n}\r\n\r\n        if (!dialogueUI && !string.IsNullOrEmpty(fallbackPanelTag))\r\n        {\r\n            var tagged = GameObject.FindGameObjectWithTag(fallbackPanelTag);\r\n            if (tagged != null) dialogueUI = tagged;\r\n        }\r\n\r\n        if (!dialogueUI && !string.IsNullOrEmpty(fallbackPanelName))\r\n        {\r\n            var foundPanel = GameObject.Find(fallbackPanelName);\r\n            if (foundPanel != null) dialogueUI = foundPanel;\r\n        }\r\n\r\n        if (!dialogueUI)\r\n        {\r\n            foreach (var canvas in FindObjectsByType<Canvas>(FindObjectsInactive.Include, FindObjectsSortMode.None))\r\n            {\r\n                var t = canvas.GetComponentInChildren<TMP_Text>(true);\r\n                if (t != null)\r\n                {\r\n                    dialogueUI = canvas.gameObject;\r\n                    dialogueText = t;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (dialogueUI && !dialogueText)\r\n        {\r\n            TMP_Text t = null;\r\n            if (!string.IsNullOrEmpty(fallbackTextName))\r\n            {\r\n                var tr = dialogueUI.transform.Find(fallbackTextName);\r\n                if (tr) t = tr.GetComponent<TMP_Text>();\r\n            }\r\n            if (!t) t = dialogueUI.GetComponentInChildren<TMP_Text>(true);\r\n\r\n            if (t)\r\n            {\r\n                dialogueText = t;\r\n                DecoupleMaterial(dialogueText);\r\n            }\r\n        }\r\n    }\r\n\r\n    [ContextMenu(\"DialogueManager/Validate Setup\")]\r\n    private void ValidateSetup()\r\n    {\r\n        Debug.Log($\"[DialogueManager] UI={(dialogueUI ? dialogueUI.name : \"null\")}  Text={(dialogueText ? dialogueText.name : \"null\")}\");\r\n        Debug.Log($\" submit={(submitAction?.action != null)} cancel={(cancelAction?.action != null)} navigate={(navigateAction?.action != null)}\");\r\n    }\r\n\r\n    private void CopyTextStyle(TMP_Text from, TMP_Text to)\r\n    {\r\n        if (from == null || to == null) return;\r\n        to.font = from.font;\r\n        to.fontSize = from.fontSize;\r\n        to.enableAutoSizing = from.enableAutoSizing;\r\n        to.fontStyle = from.fontStyle;\r\n        to.alignment = from.alignment;\r\n        to.color = from.color;\r\n        to.textWrappingMode = from.textWrappingMode;\r\n        to.richText = from.richText;\r\n        to.lineSpacing = from.lineSpacing;\r\n        to.wordSpacing = from.wordSpacing;\r\n        to.characterSpacing = from.characterSpacing;\r\n        to.overflowMode = from.overflowMode;\r\n        to.margin = from.margin;\r\n        if (to is TextMeshProUGUI ugui) ugui.raycastTarget = false;\r\n    }\r\n\r\n    private void ApplyDialogueMaterial(TMP_Text t)\r\n    {\r\n        if (t == null || dialogueText == null) return;\r\n        t.font = dialogueText.font;\r\n        var sharedPreset = dialogueText.fontSharedMaterial;\r\n        if (sharedPreset != null)\r\n            t.fontMaterial = new Material(sharedPreset);\r\n        t.color = dialogueText.color;\r\n    }\r\n\r\n    private void DecoupleMaterial(TMP_Text t)\r\n    {\r\n        if (t == null) return;\r\n        var shared = t.fontSharedMaterial;\r\n        var local = t.fontMaterial;\r\n        if (ReferenceEquals(shared, local))\r\n            t.fontMaterial = new Material(shared);\r\n    }\r\n}\r\n\r\npublic class SequenceResult\r\n{\r\n    public DialogueBlock lastChoice;\r\n    public int lastChoiceIndex = -1;\r\n    public string lastChoiceText;\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "dialogueUI",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "dialogueText",
                    "type": "TMPro.TMP_Text",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "submitAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "cancelAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "navigateAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "disableWhileOpen",
                    "type": "System.Collections.Generic.List`1[[UnityEngine.InputSystem.InputActionReference, Unity.InputSystem, Version=1.13.1.0, Culture=neutral, PublicKeyToken=null]]",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "charInterval",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "shortPunctPause",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "longPunctPause",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "minShowSeconds",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "choiceTextPrefab",
                    "type": "TMPro.TextMeshProUGUI",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "autoHideOnSceneLoad",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "autoFindUIOnOpen",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "fallbackPanelName",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "fallbackTextName",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "fallbackPanelTag",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "DialogueManager",
                "SequenceResult"
            ]
        },
        {
            "kind": 0,
            "className": "DialogueUIBinder",
            "namespace": "",
            "fullName": "DialogueUIBinder",
            "filePath": "Assets/Scripts/Dialogue/DialogueUIBinder.cs",
            "guid": "efbed507f6f96014f8d1374e664dd682",
            "source": "using UnityEngine;\r\nusing TMPro;\r\n\r\n/// <summary>\r\n/// Locates your Dialogue UI (panel + TMP text) in the scene and binds it to DialogueManager.\r\n/// Choose a locate strategy in the inspector. Safe to keep on a prefab/scene object.\r\n/// </summary>\r\n[DefaultExecutionOrder(-50)] // Bind early\r\npublic class DialogueUIBinder : MonoBehaviour\r\n{\r\n    public enum LocateMode\r\n    {\r\n        UseAssigned,   // Use serialized references as-is\r\n        ByTag,         // Find panel by tag\r\n        ByName,        // Find panel (and optionally text) by exact names\r\n        DeepScan       // Scan canvases for the first TMP_Text\r\n    }\r\n\r\n    [Header(\"Binding Target\")]\r\n    [Tooltip(\"If null, will use DialogueManager.Instance.\")]\r\n    [SerializeField] private DialogueManager manager;\r\n\r\n    [Header(\"UI References (optional)\")]\r\n    [Tooltip(\"Root of the dialogue UI (usually a panel under a Canvas).\")]\r\n    [SerializeField] private GameObject dialoguePanel;\r\n    [Tooltip(\"TMP_Text used to render the dialogue text.\")]\r\n    [SerializeField] private TMP_Text dialogueText;\r\n\r\n    [Header(\"Locate Strategy\")]\r\n    [SerializeField] private LocateMode locateStrategy = LocateMode.UseAssigned;\r\n\r\n    [Tooltip(\"When LocateMode = ByTag, set the panel's tag here.\")]\r\n    [SerializeField] private string panelTag = \"\";\r\n\r\n    [Tooltip(\"When LocateMode = ByName, exact name of the panel GameObject.\")]\r\n    [SerializeField] private string panelName = \"DialogueUI\";\r\n    [Tooltip(\"When LocateMode = ByName, exact name of the TMP_Text child (optional).\")]\r\n    [SerializeField] private string textName = \"DialogueText\";\r\n\r\n    [Header(\"Behavior\")]\r\n    [Tooltip(\"Automatically bind on Awake.\")]\r\n    [SerializeField] private bool bindOnAwake = true;\r\n    [Tooltip(\"Clone the font material on the bound TMP_Text so changes don't affect shared presets.\")]\r\n    [SerializeField] private bool decoupleMaterial = true;\r\n    [Tooltip(\"Ensure CanvasGroup/Canvas are interactable/visible after binding.\")]\r\n    [SerializeField] private bool ensureVisibility = true;\r\n    [Tooltip(\"Print helpful logs.\")]\r\n    [SerializeField] private bool verboseLogs = true;\r\n\r\n    private void Awake()\r\n    {\r\n        if (bindOnAwake) TryBindNow();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Attempts to locate the panel + text according to the chosen strategy and bind them to DialogueManager.\r\n    /// </summary>\r\n    [ContextMenu(\"DialogueUIBinder/Try Bind Now\")]\r\n    public void TryBindNow()\r\n    {\r\n        if (!manager) manager = DialogueManager.Instance;\r\n\r\n        // 1) Resolve UI references according to strategy\r\n        switch (locateStrategy)\r\n        {\r\n            case LocateMode.UseAssigned:\r\n                // use existing serialized refs\r\n                break;\r\n\r\n            case LocateMode.ByTag:\r\n                if (!dialoguePanel && !string.IsNullOrEmpty(panelTag))\r\n                {\r\n                    var tagged = GameObject.FindGameObjectWithTag(panelTag);\r\n                    if (tagged) dialoguePanel = tagged;\r\n                }\r\n                break;\r\n\r\n            case LocateMode.ByName:\r\n                if (!dialoguePanel && !string.IsNullOrEmpty(panelName))\r\n                {\r\n                    var go = GameObject.Find(panelName);\r\n                    if (go) dialoguePanel = go;\r\n                }\r\n                if (dialoguePanel && !dialogueText)\r\n                {\r\n                    TMP_Text found = null;\r\n                    if (!string.IsNullOrEmpty(textName))\r\n                    {\r\n                        var tr = dialoguePanel.transform.Find(textName);\r\n                        if (tr) found = tr.GetComponent<TMP_Text>();\r\n                    }\r\n                    if (!found) found = dialoguePanel.GetComponentInChildren<TMP_Text>(true);\r\n                    dialogueText = found;\r\n                }\r\n                break;\r\n\r\n            case LocateMode.DeepScan:\r\n                if (!dialoguePanel || !dialogueText)\r\n                {\r\n                    // Find any Canvas with a TMP_Text child (includes inactive)\r\n#if UNITY_2022_1_OR_NEWER\r\n                    var canvases = FindObjectsByType<Canvas>(FindObjectsInactive.Include, FindObjectsSortMode.None);\r\n#else\r\n                    var canvases = Resources.FindObjectsOfTypeAll<Canvas>();\r\n#endif\r\n                    foreach (var c in canvases)\r\n                    {\r\n                        var t = c.GetComponentInChildren<TMP_Text>(true);\r\n                        if (t != null)\r\n                        {\r\n                            dialoguePanel = c.gameObject;\r\n                            dialogueText = t;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n\r\n        // 2) Fallback: if we have a panel but no text, search under panel\r\n        if (dialoguePanel && !dialogueText)\r\n            dialogueText = dialoguePanel.GetComponentInChildren<TMP_Text>(true);\r\n\r\n        // 3) Early validation\r\n        if (!dialoguePanel || !dialogueText)\r\n        {\r\n            if (verboseLogs)\r\n                Debug.LogWarning($\"[DialogueUIBinder] Binding failed. Panel={(dialoguePanel ? dialoguePanel.name : \"null\")}  Text={(dialogueText ? dialogueText.name : \"null\")}\", this);\r\n            return;\r\n        }\r\n\r\n        // 4) Optional: decouple font material so edits don't touch shared presets\r\n        if (decoupleMaterial && dialogueText)\r\n        {\r\n            var shared = dialogueText.fontSharedMaterial;\r\n            var local = dialogueText.fontMaterial;\r\n            if (ReferenceEquals(shared, local))\r\n                dialogueText.fontMaterial = new Material(shared);\r\n        }\r\n\r\n        // 5) Ensure UI is visible/interactive\r\n        if (ensureVisibility && dialoguePanel)\r\n        {\r\n            var cg = dialoguePanel.GetComponent<CanvasGroup>();\r\n            if (!cg) cg = dialoguePanel.AddComponent<CanvasGroup>();\r\n            cg.alpha = 1f;\r\n            cg.interactable = true;\r\n            cg.blocksRaycasts = true;\r\n\r\n            var canvas = dialoguePanel.GetComponentInParent<Canvas>(true);\r\n            if (canvas) canvas.enabled = true;\r\n        }\r\n\r\n        // 6) Bind to manager\r\n        if (!manager) manager = DialogueManager.Instance;\r\n        if (manager)\r\n        {\r\n            manager.BindUI(dialoguePanel, dialogueText);\r\n            if (verboseLogs)\r\n                Debug.Log($\"[DialogueUIBinder] Bound to manager. Panel={dialoguePanel.name}, Text={dialogueText.name}\", this);\r\n        }\r\n        else\r\n        {\r\n            if (verboseLogs)\r\n                Debug.LogWarning(\"[DialogueUIBinder] DialogueManager.Instance not found. Binding deferred.\", this);\r\n        }\r\n    }\r\n\r\n    /// <summary>Quick inspector helper to print current refs.</summary>\r\n    [ContextMenu(\"DialogueUIBinder/Validate Local UI\")]\r\n    private void ValidateLocal()\r\n    {\r\n        Debug.Log($\"[DialogueUIBinder] Panel={(dialoguePanel ? dialoguePanel.name : \"null\")}  Text={(dialogueText ? dialogueText.name : \"null\")}\", this);\r\n    }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "manager",
                    "type": "DialogueManager",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "dialoguePanel",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "dialogueText",
                    "type": "TMPro.TMP_Text",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "locateStrategy",
                    "type": "DialogueUIBinder+LocateMode",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "panelTag",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "panelName",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "textName",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "bindOnAwake",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "decoupleMaterial",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "ensureVisibility",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "verboseLogs",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "DialogueUIBinder",
                "LocateMode"
            ]
        },
        {
            "kind": 0,
            "className": "DoorInteraction",
            "namespace": "",
            "fullName": "DoorInteraction",
            "filePath": "Assets/Scripts/World Interaction Scripts/DoorInteraction.cs",
            "guid": "5ae6584b74433ff4182d0569d2310a45",
            "source": "using UnityEngine;\r\nusing UnityEngine.SceneManagement;\r\n\r\npublic class DoorInteraction : MonoBehaviour\r\n{\r\n    [SerializeField]\r\n    public GameObject doorObject; // Assign your door object with Animator\r\n\r\n    [SerializeField]\r\n    private GameObject playerInputController; // Assign the player input/controller object that should be disabled during cutscene\r\n\r\n    [SerializeField]\r\n    private CutsceneManager cutsceneManager; // Assign your scene manager object here\r\n\r\n    private DoorTriggerZone doorTriggerZone;\r\n\r\n    [SerializeField]\r\n    private string nextSceneName; // Set your next scene's name here\r\n\r\n    private Animator doorAnimator;\r\n    public static bool isPlayerNear = false;\r\n\r\n    void Start()\r\n    {\r\n        if (doorObject != null)\r\n        {\r\n            doorAnimator = doorObject.GetComponent<Animator>();\r\n            if (doorAnimator == null)\r\n            {\r\n                Debug.LogError(\"Animator component not found on the door object.\", this);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            Debug.LogError(\"doorObject not assigned.\");\r\n        }\r\n\r\n        if (cutsceneManager == null)\r\n        {\r\n            Debug.LogError(\"CutsceneManager not assigned.\");\r\n        }\r\n\r\n        if (playerInputController == null)\r\n        {\r\n            Debug.LogError(\"Player input controller not assigned.\");\r\n        }\r\n        if (isPlayerNear && (Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetKeyDown(KeyCode.Return)))\r\n        {\r\n            // Call the sequence\r\n            if (doorTriggerZone != null)\r\n            {\r\n                doorTriggerZone.ActivateDoorSequence();\r\n            }\r\n            else\r\n            {\r\n                Debug.LogError(\"doorTriggerZone instance not assigned.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    // Called by Trigger Zone script when player enters\r\n    public void OnPlayerEnterRange()\r\n    {\r\n        isPlayerNear = true;\r\n        Debug.Log(\"isPlayerNear=True\");\r\n    }\r\n\r\n    // Called by Trigger Zone script when player leaves\r\n    public void OnPlayerExitRange()\r\n    {\r\n        isPlayerNear = false;\r\n        Debug.Log(\"isPlayerNear=False\");\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        // Check for button press (Joystick 'A' or Return key)\r\n        if (isPlayerNear && ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetKeyDown(KeyCode.Return))))\r\n        {\r\n            Debug.Log(\"Button detected, triggering door and cutscene...\");\r\n            if (doorAnimator != null)\r\n            {\r\n                doorAnimator.SetTrigger(\"Open\");\r\n                Debug.Log(\"Door 'Open' trigger set\");\r\n            }\r\n\r\n            // Trigger the cutscene, disable input, and transition\r\n            if (cutsceneManager != null)\r\n            {\r\n                cutsceneManager.PlayCutscene(() =>\r\n                {\r\n                    // Callback after cutscene completes, load new scene\r\n                    SceneManager.LoadScene(nextSceneName);\r\n\r\n                    isPlayerNear = false;\r\n                });\r\n            }\r\n        }\r\n    }\r\n}",
            "serializedFields": [
                {
                    "name": "doorObject",
                    "type": "UnityEngine.GameObject",
                    "isPublic": true,
                    "hasSerializeField": true
                },
                {
                    "name": "playerInputController",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "cutsceneManager",
                    "type": "CutsceneManager",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "nextSceneName",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "DoorInteraction"
            ]
        },
        {
            "kind": 0,
            "className": "DoorTriggerZone",
            "namespace": "",
            "fullName": "DoorTriggerZone",
            "filePath": "Assets/Scripts/World Interaction Scripts/DoorTriggerZone.cs",
            "guid": "199f3d9578a88794c90e729d0703f7fb",
            "source": "using UnityEngine;\r\nusing UnityEngine.SceneManagement;\r\nusing System.Collections;\r\n\r\npublic class DoorTriggerZone : MonoBehaviour\r\n{\r\n    [SerializeField]\r\n    private GameObject doorObject; // Door with Animator and DoorInteraction\r\n    \r\n    [SerializeField]\r\n    private GameObject player; // Reference to the Player GameObject\r\n    \r\n    [SerializeField]\r\n    private GameObject cutsceneManagerObject; // Contains your CutsceneManager\r\n    \r\n    [SerializeField]\r\n    private string nextSceneName = \"NextScene\"; // Scene to load after the cutscene\r\n    \r\n    [SerializeField]\r\n    private float cutsceneDuration = 3f; // How long the door animation/cutscene lasts\r\n    \r\n    [SerializeField]\r\n    private Transform targetPoint; // Where the player should stand (assign in inspector)\r\n\r\n    private DoorInteraction doorInteraction;\r\n    private CutsceneManager cutsceneManager;\r\n\r\n    void Start()\r\n    {\r\n        // Find the Player if not assigned\r\n        if (player == null)\r\n        {\r\n            player = GameObject.FindGameObjectWithTag(\"Player\");\r\n            Debug.Log(\"[Start] Player assigned via tag\");\r\n        }\r\n\r\n        // Get DoorInteraction component\r\n        if (doorObject != null)\r\n        {\r\n            doorInteraction = doorObject.GetComponent<DoorInteraction>();\r\n            if (doorInteraction == null)\r\n                Debug.LogError(\"[Start] DoorInteraction not found on doorObject\");\r\n        }\r\n        else\r\n        {\r\n            Debug.LogError(\"[Start] doorObject not assigned\");\r\n        }\r\n\r\n        // Get CutsceneManager component\r\n        if (cutsceneManagerObject != null)\r\n        {\r\n            cutsceneManager = cutsceneManagerObject.GetComponent<CutsceneManager>();\r\n            if (cutsceneManager == null)\r\n                Debug.LogError(\"[Start] CutsceneManager not found\");\r\n        }\r\n    }\r\n\r\n    private void OnTriggerEnter(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\"))\r\n        {\r\n            doorInteraction?.OnPlayerEnterRange();\r\n            Debug.Log(\"Player entered trigger zone\");\r\n        }\r\n    }\r\n\r\n    private void OnTriggerExit(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\"))\r\n        {\r\n            doorInteraction?.OnPlayerExitRange();\r\n            Debug.Log(\"Player exited trigger zone\");\r\n        }\r\n    }\r\n\r\n    // Call this method externally, e.g., from your input logic\r\n    public void ActivateDoorSequence()\r\n    {\r\n        StartCoroutine(DoorSequence());\r\n    }\r\n\r\n    private IEnumerator DoorSequence()\r\n    {\r\n        Debug.Log(\"[DoorSequence] Starting sequence\");\r\n\r\n        Animator playerAnim = player.GetComponent<Animator>();\r\n        if (playerAnim != null)\r\n        {\r\n            // Play the door opening animation directly\r\n            playerAnim.Play(\"OpenDoor\", 0, 0f); // adjust clip name if different\r\n            Debug.Log(\"[Fix] Player animation forced to OpenDoor\");\r\n        }\r\n\r\n        // 1. Disable player input\r\n        var controller = player.GetComponent<ThirdPersonController>();\r\n        if (controller != null)\r\n        {\r\n            Debug.Log(\"[Controller] Disabling player controller\");\r\n            controller.enabled = false;\r\n        }\r\n\r\n        // 2. Calculate target position\r\n        Vector3 targetPosition = (targetPoint != null) ? targetPoint.position : doorObject.transform.position + new Vector3(0, 0, -1);\r\n        Debug.Log(\"[Move] Moving player to: \" + targetPosition);\r\n\r\n        // 3. Teleport player\r\n        player.transform.position = targetPosition;\r\n\r\n        // 4. Rotate the player to match target point's Y rotation\r\n        if (targetPoint != null)\r\n        {\r\n            Vector3 eulerAngles = player.transform.rotation.eulerAngles;\r\n            eulerAngles.y = targetPoint.rotation.eulerAngles.y;\r\n            player.transform.rotation = Quaternion.Euler(eulerAngles);\r\n            Debug.Log(\"[Rotate] Player Y rotation set to: \" + eulerAngles.y);\r\n        }\r\n\r\n        // 5. Trigger door opening animation\r\n        var doorAnimator = doorObject.GetComponent<Animator>();\r\n        if (doorAnimator != null)\r\n        {\r\n            Debug.Log(\"[Door] Triggering 'Open'\");\r\n            doorAnimator.SetTrigger(\"Open\");\r\n        }\r\n\r\n        // 6. Play cutscene (wait until finished)\r\n        bool cutsceneDone = false;\r\n        if (cutsceneManager != null)\r\n        {\r\n            cutsceneManager.PlayCutscene(() =>\r\n            {\r\n                Debug.Log(\"[Cutscene] Completed\");\r\n                cutsceneDone = true;\r\n            });\r\n        }\r\n        else\r\n        {\r\n            Debug.LogWarning(\"[Cutscene] No CutsceneManager assigned\");\r\n            yield return new WaitForSeconds(cutsceneDuration);\r\n            cutsceneDone = true;\r\n        }\r\n\r\n        while (!cutsceneDone)\r\n            yield return null;\r\n\r\n        // 7. Re-enable controller\r\n        if (controller != null)\r\n        {\r\n            Debug.Log(\"[Controller] Re-enabling player controller\");\r\n            controller.enabled = true;\r\n        }\r\n\r\n        DoorInteraction.isPlayerNear = false;\r\n\r\n        // 8. Load scene\r\n        Debug.Log(\"[Scene] Loading: \" + nextSceneName);\r\n        SceneManager.LoadScene(nextSceneName);\r\n        DoorInteraction.isPlayerNear = false;\r\n\r\n    }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "doorObject",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "player",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "cutsceneManagerObject",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "nextSceneName",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "cutsceneDuration",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "targetPoint",
                    "type": "UnityEngine.Transform",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "DoorTriggerZone"
            ]
        },
        {
            "kind": 0,
            "className": "InteractInputDebugger",
            "namespace": "",
            "fullName": "InteractInputDebugger",
            "filePath": "Assets/Scripts/Debuggers/InteractInputDebugger.cs",
            "guid": "56dd6d4368e727b42953eadfdf4f5a0a",
            "source": "using UnityEngine;\r\nusing UnityEngine.InputSystem;\r\n\r\npublic class InteractInputDebugger : MonoBehaviour\r\n{\r\n    [SerializeField] private InputActionReference interactAction;\r\n\r\n    private void OnEnable()\r\n    {\r\n        if (interactAction == null) { Debug.LogError(\"[InteractInputDebugger] No action assigned.\"); return; }\r\n        interactAction.action.started   += OnStarted;\r\n        interactAction.action.performed += OnPerf;\r\n        interactAction.action.canceled  += OnCanceled;\r\n        interactAction.action.Enable();\r\n        Debug.Log($\"[InteractInputDebugger] Enabled '{interactAction.action.name}' (map: {interactAction.action.actionMap?.name})\");\r\n        for (int i = 0; i < interactAction.action.bindings.Count; i++)\r\n        {\r\n            var b = interactAction.action.bindings[i];\r\n            Debug.Log($\"[InteractInputDebugger] Binding[{i}] path='{b.path}' groups='{b.groups}' interactions='{b.interactions}'\");\r\n        }\r\n    }\r\n    private void OnDisable()\r\n    {\r\n        if (interactAction == null) return;\r\n        interactAction.action.started   -= OnStarted;\r\n        interactAction.action.performed -= OnPerf;\r\n        interactAction.action.canceled  -= OnCanceled;\r\n        interactAction.action.Disable();\r\n    }\r\n    private void OnStarted(InputAction.CallbackContext c)  { Debug.Log($\"[InteractInputDebugger] STARTED {c.control?.path}\"); }\r\n    private void OnPerf(InputAction.CallbackContext c)     { Debug.Log($\"[InteractInputDebugger] PERFORMED {c.control?.path}\"); }\r\n    private void OnCanceled(InputAction.CallbackContext c) { Debug.Log($\"[InteractInputDebugger] CANCELED\"); }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "interactAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "InteractInputDebugger"
            ]
        },
        {
            "kind": 0,
            "className": "ItemInteraction",
            "namespace": "",
            "fullName": "ItemInteraction",
            "filePath": "Assets/Scripts/World Interaction Scripts/ItemInteraction.cs",
            "guid": "ddb0395ae3a230445adcfb080aa066a1",
            "source": "using UnityEngine;\r\nusing UnityEngine.InputSystem;\r\n\r\n[RequireComponent(typeof(Collider))]\r\npublic class ItemInteraction : MonoBehaviour\r\n{\r\n    [Header(\"Data\")]\r\n    [SerializeField] private ItemData itemData;\r\n\r\n    [Header(\"Interaction Rules\")]\r\n    [Tooltip(\"If OFF, the object will NEVER be removed from the scene or marked collected. All other logic still runs.\")]\r\n    [SerializeField] private bool canPickUp = true;\r\n\r\n    [Header(\"Input\")]\r\n    [Tooltip(\"Bind to your Gameplay/Interact action (Gamepad South / Keyboard E).\")]\r\n    [SerializeField] private InputActionReference interactAction;\r\n\r\n    private bool playerInRange;\r\n    private bool pressInProgress;       // locks while the same press is held\r\n    private float suppressUntil;        // short cooldown window after dialog closes\r\n    private bool waitForReleaseAfterDialog; // require Interact to be fully released\r\n\r\n    private void Reset()\r\n    {\r\n        var col = GetComponent<Collider>();\r\n        if (col) col.isTrigger = true;\r\n    }\r\n\r\n    private void Awake()\r\n    {\r\n        Debug.Log($\"[ItemInteraction:{name}] Awake. itemData={(itemData ? itemData.itemName : \"NULL\")} canPickUp={canPickUp} action={(interactAction ? interactAction.action?.name : \"NULL\")} map='{interactAction?.action?.actionMap?.name}'\");\r\n    }\r\n\r\n    private void OnEnable()\r\n    {\r\n        if (interactAction?.action == null)\r\n        {\r\n            Debug.LogError($\"[ItemInteraction:{name}] No InputActionReference assigned.\");\r\n        }\r\n        else\r\n        {\r\n            interactAction.action.started   += OnInteractStarted;\r\n            interactAction.action.performed += OnInteractPerformed;\r\n            interactAction.action.canceled  += OnInteractCanceled;\r\n\r\n            // ✅ SAFE: enable only if not already enabled (don’t fight other systems)\r\n            if (!interactAction.action.enabled)\r\n                interactAction.action.Enable();\r\n\r\n            for (int i = 0; i < interactAction.action.bindings.Count; i++)\r\n            {\r\n                var b = interactAction.action.bindings[i];\r\n                Debug.Log($\"[ItemInteraction:{name}] Binding[{i}] path='{b.path}' groups='{b.groups}' interactions='{b.interactions}'\");\r\n            }\r\n        }\r\n\r\n        DialogueManager.OnDialogActiveChanged += OnDialogActiveChanged;\r\n    }\r\n\r\n    private void OnDisable()\r\n    {\r\n        if (interactAction?.action != null)\r\n        {\r\n            interactAction.action.started   -= OnInteractStarted;\r\n            interactAction.action.performed -= OnInteractPerformed;\r\n            interactAction.action.canceled  -= OnInteractCanceled;\r\n\r\n            // 🚫 IMPORTANT: DO NOT Disable() here — shared action would be turned off for all items.\r\n            // interactAction.action.Disable();  <-- removed\r\n        }\r\n\r\n        DialogueManager.OnDialogActiveChanged -= OnDialogActiveChanged;\r\n        Debug.Log($\"[ItemInteraction:{name}] Unsubscribed from interact action.\");\r\n    }\r\n\r\n    private void Start()\r\n    {\r\n        var ss = SaveSystem.Instance;\r\n        Debug.Log($\"[ItemInteraction:{name}] Start. SaveSystem present={(ss != null)}\");\r\n\r\n        if (!itemData)\r\n        {\r\n            Debug.LogError($\"[ItemInteraction:{name}] ItemData is NULL.\");\r\n            return;\r\n        }\r\n\r\n        // Only auto-hide if this item CAN be picked up and has been collected before\r\n        if (canPickUp && ss != null && ss.IsItemCollected(itemData.Guid))\r\n        {\r\n            Debug.Log($\"[ItemInteraction:{name}] Already collected '{itemData.itemName}'. Hiding object.\");\r\n            gameObject.SetActive(false);\r\n        }\r\n        else\r\n        {\r\n            Debug.Log($\"[ItemInteraction:{name}] Not collected (or non-pickup). Visible and waiting.\");\r\n        }\r\n    }\r\n\r\n    private void Update()\r\n    {\r\n        // After dialog closes, wait until Interact is fully released, then unlock\r\n        if (waitForReleaseAfterDialog && interactAction?.action != null)\r\n        {\r\n            float val = 0f;\r\n            try { val = interactAction.action.ReadValue<float>(); } catch { }\r\n            if (val <= 0.01f)\r\n            {\r\n                waitForReleaseAfterDialog = false;\r\n                pressInProgress = false; // allow the next *fresh* press\r\n                Debug.Log($\"[ItemInteraction:{name}] Interact released after dialog; re-arming interaction.\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private void OnTriggerEnter(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\"))\r\n        {\r\n            playerInRange = true;\r\n            Debug.Log($\"[ItemInteraction:{name}] Player IN range.\");\r\n        }\r\n    }\r\n    private void OnTriggerExit(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\"))\r\n        {\r\n            playerInRange = false;\r\n            Debug.Log($\"[ItemInteraction:{name}] Player OUT of range.\");\r\n        }\r\n    }\r\n\r\n    private void OnInteractStarted(InputAction.CallbackContext ctx)\r\n    {\r\n        if (DialogueManager.Instance?.IsActive() == true) return;\r\n        if (Time.unscaledTime < suppressUntil) return;\r\n        if (waitForReleaseAfterDialog) return;\r\n        TryInteractOnce();\r\n    }\r\n\r\n    private void OnInteractPerformed(InputAction.CallbackContext ctx)\r\n    {\r\n        if (DialogueManager.Instance?.IsActive() == true) return;\r\n        if (Time.unscaledTime < suppressUntil) return;\r\n        if (waitForReleaseAfterDialog) return;\r\n        TryInteractOnce();\r\n    }\r\n\r\n    private void OnInteractCanceled(InputAction.CallbackContext ctx)\r\n    {\r\n        pressInProgress = false; // unlock on release (prevents re-trigger loops)\r\n    }\r\n\r\n    private void OnDialogActiveChanged(bool active)\r\n    {\r\n        if (!active)\r\n        {\r\n            // Dialog just closed: add a brief cooldown and require release\r\n            suppressUntil = Time.unscaledTime + 0.25f;\r\n            waitForReleaseAfterDialog = true;\r\n            Debug.Log($\"[ItemInteraction:{name}] Dialog closed -> suppress interactions until {suppressUntil:0.00} and wait for release.\");\r\n        }\r\n    }\r\n\r\n    void TryInteractOnce()\r\n    {\r\n        if (PauseMenuController.IsPaused) return;\r\n        if (pressInProgress) return;\r\n        if (!playerInRange) return;\r\n        if (!itemData) { Debug.LogError(\"No ItemData\"); return; }\r\n\r\n        pressInProgress = true; // cleared on Interact.canceled or release-after-dialog\r\n\r\n        // Prefer graph if present\r\n        if (itemData.graph != null)\r\n        {\r\n            DialogueGraphRunner.Play(itemData.graph, result =>\r\n            {\r\n                if (result.pickupApproved)\r\n                    DoPickup(); // respects canPickUp inside\r\n\r\n                // unlock handled by canceled / release-after-dialog\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Otherwise use authored linear list (if any)\r\n        if (itemData.dialogue != null && itemData.dialogue.Count > 0)\r\n        {\r\n            DialogueManager.Instance.StartSequence(itemData.dialogue, result =>\r\n            {\r\n                bool approved = false;\r\n                if (result != null && result.lastChoice != null &&\r\n                    result.lastChoice.semantic == ChoiceSemantic.PickupYes)\r\n                {\r\n                    approved = (result.lastChoiceIndex == result.lastChoice.yesIndex);\r\n                }\r\n                else\r\n                {\r\n                    approved = true; // default if no choice\r\n                }\r\n\r\n                if (approved) DoPickup(); // respects canPickUp\r\n            });\r\n            return;\r\n        }\r\n\r\n        // Legacy fallback\r\n        DialogueManager.Instance.StartSequence(\r\n            new System.Collections.Generic.List<DialogueBlock> {\r\n                new DialogueBlock { type = BlockType.Text, text = itemData.description }\r\n            },\r\n            _ => { DoPickup(); } // respects canPickUp\r\n        );\r\n    }\r\n\r\n    private void DoPickup()\r\n    {\r\n        Debug.Log($\"[ItemInteraction:{name}] DoPickup called (canPickUp={canPickUp}).\");\r\n\r\n        if (itemData.canBeClue && itemData.clueData != null)\r\n            ClueManager.Instance?.DiscoverClue(itemData.clueData);\r\n\r\n        if (canPickUp)\r\n        {\r\n            SaveSystem.Instance?.MarkItemCollected(itemData.Guid);\r\n            gameObject.SetActive(false); // triggers OnDisable, but we no longer Disable() the action\r\n        }\r\n        else\r\n        {\r\n            Debug.Log($\"[ItemInteraction:{name}] Pickup approved, but 'Can Pick Up?' is OFF — leaving object in scene.\");\r\n        }\r\n    }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "itemData",
                    "type": "ItemData",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "canPickUp",
                    "type": "System.Boolean",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "interactAction",
                    "type": "UnityEngine.InputSystem.InputActionReference",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "ItemInteraction"
            ]
        },
        {
            "kind": 0,
            "className": "ObjectIlluminator",
            "namespace": "",
            "fullName": "ObjectIlluminator",
            "filePath": "Assets/Scripts/World Interaction Scripts/ObjectIlluminator.cs",
            "guid": "200762001b040a74b851668e04a3ae74",
            "source": "using UnityEngine;\r\nusing System.Collections;\r\n\r\npublic class ObjectIlluminator : MonoBehaviour\r\n{\r\n    [SerializeField]\r\n    private GameObject targetObject;  // Assign in inspector\r\n    [SerializeField]\r\n    private Color baseOutlineColor = Color.white;\r\n    private Material targetMaterial;\r\n    private bool playerNearby = false;\r\n    private Coroutine pulseCoroutine;\r\n\r\n    void Start()\r\n    {\r\n        if (targetObject != null)\r\n        {\r\n            // Get a unique instance of the material\r\n            targetMaterial = targetObject.GetComponent<Renderer>().material;\r\n\r\n            // Debug info\r\n            //Debug.Log(\"Target material assigned: \" + targetMaterial.name);\r\n\r\n            \r\n        }\r\n        else\r\n        {\r\n            //Debug.LogError(\"Target Object not assigned.\", this);\r\n        }\r\n    }\r\n\r\n    private void OnTriggerEnter(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\") && pulseCoroutine == null)\r\n        {\r\n            playerNearby = true;\r\n            //Debug.Log(\"Player entered trigger zone\");\r\n            pulseCoroutine = StartCoroutine(PulseOutline());\r\n        }\r\n    }\r\n\r\n    private void OnTriggerExit(Collider other)\r\n    {\r\n        if (other.CompareTag(\"Player\") && pulseCoroutine != null)\r\n        {\r\n            playerNearby = false;\r\n            //Debug.Log(\"Player exited trigger zone\");\r\n            StopCoroutine(pulseCoroutine);\r\n            pulseCoroutine = null;\r\n            SetOutlineColor(0f); // Reset to transparent or default\r\n        }\r\n    }\r\n\r\n    private IEnumerator PulseOutline()\r\n    {\r\n        while (playerNearby)\r\n        {\r\n            float alpha = (Mathf.Sin(Time.time * 2f) + 1f) / 2f; // Pulsing alpha\r\n            SetOutlineColor(alpha);\r\n            yield return null;\r\n        }\r\n    }\r\n\r\n    private void SetOutlineColor(float alpha)\r\n    {\r\n          if (targetMaterial != null)\r\n    {\r\n        Color newColor = baseOutlineColor;\r\n        newColor.a = alpha;\r\n\r\n        //Debug.Log($\"Setting _OutlineColor to {newColor}\");\r\n        targetMaterial.SetColor(\"_OutlineColor\", newColor);\r\n    }\r\n\r\n    }\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "targetObject",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "baseOutlineColor",
                    "type": "UnityEngine.Color",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "ObjectIlluminator"
            ]
        },
        {
            "kind": 0,
            "className": "PauseMenuController",
            "namespace": "",
            "fullName": "PauseMenuController",
            "filePath": "Assets/Scripts/Draft UI Scripts/PauseMenuController.cs",
            "guid": "8e6ebbdb0c5f95044b13b4112d24f864",
            "source": "using UnityEngine;\r\nusing UnityEngine.UI;\r\nusing TMPro;\r\nusing UnityEngine.EventSystems;\r\nusing UnityEngine.InputSystem;\r\nusing UnityEngine.SceneManagement;\r\n\r\npublic class PauseMenuController : MonoBehaviour\r\n{\r\n    [Header(\"UI\")]\r\n    [SerializeField] private GameObject pauseMenuUI;       // main pause list panel\r\n    [SerializeField] private Button[] menuButtons;\r\n    [SerializeField] private Button cognitionButton;\r\n\r\n    // Panel that visually contains the board (canvas/panel)\r\n    [SerializeField] private GameObject cognitionBoardUI;\r\n\r\n    // The actual board behaviour (may be on a child that auto-disables in Awake)\r\n    [SerializeField] private CognitionBoard cognitionBoard;\r\n\r\n    [Header(\"Selection Colors\")]\r\n    [SerializeField] private Color selectedColor = Color.yellow;\r\n    [SerializeField] private Color defaultColor = Color.white;\r\n\r\n    [Header(\"Input (UI action map)\")]\r\n    [SerializeField] private InputActionAsset inputActions;\r\n\r\n    // NEW: gameplay map name + cached map (your gameplay map is called \"Player\")\r\n    [Header(\"Gameplay Action Map\")]\r\n    [Tooltip(\"Name of the gameplay action map to disable while paused.\")]\r\n    [SerializeField] private string gameplayMapName = \"Player\";\r\n    private InputActionMap gameplayMap; // NEW\r\n\r\n    private InputActionMap uiActionMap;\r\n    private InputAction navigateAction;\r\n    private InputAction submitAction;\r\n    private InputAction cancelAction;\r\n\r\n    private int currentSelectionIndex = 0;\r\n\r\n    // Keep existing instance flags…\r\n    private bool isPaused = false;\r\n    private bool isMenuActive = false;\r\n    private bool isInSubMenu = false;\r\n\r\n    // NEW: global pause flag other systems can query safely\r\n    public static bool IsPaused { get; private set; } = false;\r\n\r\n    private float lastDPadVertical = 0f;\r\n    private float dpadHoldStartTime = 0f;\r\n    [SerializeField] private float moveCooldown = 0.2f;\r\n\r\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]\r\n    private static void ResetStaticPauseFlag()\r\n{\r\n    IsPaused = false;\r\n}\r\n\r\n    void Awake()\r\n    {\r\n        uiActionMap = inputActions?.FindActionMap(\"UI\", true);\r\n        navigateAction = uiActionMap?.FindAction(\"Navigate\");\r\n        submitAction = uiActionMap?.FindAction(\"Submit\");\r\n        cancelAction = uiActionMap?.FindAction(\"Cancel\");\r\n\r\n        // NEW: cache the gameplay map (\"Player\")\r\n        gameplayMap = inputActions?.FindActionMap(gameplayMapName, false);\r\n        if (gameplayMap == null)\r\n        {\r\n            Debug.LogWarning($\"[PauseMenu] Could not find gameplay map '{gameplayMapName}'. \" +\r\n                             $\"World interactions may remain enabled while paused.\");\r\n        }\r\n\r\n        uiActionMap?.Disable();\r\n\r\n        if (pauseMenuUI) pauseMenuUI.SetActive(false);\r\n        if (cognitionBoardUI) cognitionBoardUI.SetActive(false);\r\n        // NOTE: cognitionBoard itself may be inactive because its Awake() sets it false—that’s OK.\r\n        UpdateButtonColors();\r\n    }\r\n\r\n    void OnEnable()\r\n    {\r\n        if (navigateAction != null) navigateAction.performed += OnNavigate;\r\n        if (submitAction != null) submitAction.performed += OnSubmit;\r\n        if (cancelAction != null) cancelAction.performed += OnCancel;\r\n    }\r\n\r\n    void OnDisable()\r\n    {\r\n        if (navigateAction != null) navigateAction.performed -= OnNavigate;\r\n        if (submitAction != null) submitAction.performed -= OnSubmit;\r\n        if (cancelAction != null) cancelAction.performed -= OnCancel;\r\n\r\n        uiActionMap?.Disable();\r\n        // NOTE: we do NOT touch gameplayMap here; resume handles re-enabling.\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        // Toggle pause (Esc or Start)\r\n        if (Keyboard.current?.escapeKey.wasPressedThisFrame == true ||\r\n            Gamepad.current?.startButton.wasPressedThisFrame == true)\r\n        {\r\n            if (isPaused) ResumeGame();\r\n            else PauseGame();\r\n        }\r\n\r\n        if (isPaused && isMenuActive && !isInSubMenu)\r\n            HandleDPadNavigation();\r\n    }\r\n\r\n    private void HandleDPadNavigation()\r\n    {\r\n        Vector2 dpadInput = navigateAction?.ReadValue<Vector2>() ?? Vector2.zero;\r\n        float deadZone = 0.5f;\r\n        float currentDPadY = dpadInput.y;\r\n        float currentTime = Time.unscaledTime;\r\n        bool shouldMove = false;\r\n\r\n        if (Mathf.Abs(currentDPadY) > deadZone && menuButtons != null && menuButtons.Length > 0)\r\n        {\r\n            float direction = Mathf.Sign(currentDPadY);\r\n            if (direction != lastDPadVertical && lastDPadVertical != 0f)\r\n            {\r\n                shouldMove = true;\r\n                lastDPadVertical = direction;\r\n                dpadHoldStartTime = currentTime;\r\n            }\r\n            else if (direction == lastDPadVertical && currentTime - dpadHoldStartTime > moveCooldown)\r\n            {\r\n                shouldMove = true;\r\n                dpadHoldStartTime = currentTime;\r\n            }\r\n            else if (lastDPadVertical == 0f)\r\n            {\r\n                shouldMove = true;\r\n                lastDPadVertical = direction;\r\n                dpadHoldStartTime = currentTime;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            lastDPadVertical = 0f;\r\n            dpadHoldStartTime = 0f;\r\n        }\r\n\r\n        if (shouldMove && menuButtons != null && menuButtons.Length > 0)\r\n        {\r\n            if (currentDPadY > deadZone)\r\n                currentSelectionIndex = (currentSelectionIndex - 1 + menuButtons.Length) % menuButtons.Length;\r\n            else if (currentDPadY < -deadZone)\r\n                currentSelectionIndex = (currentSelectionIndex + 1) % menuButtons.Length;\r\n\r\n            UpdateButtonColors();\r\n        }\r\n    }\r\n\r\n    private void OnNavigate(InputAction.CallbackContext context) { /* optional */ }\r\n\r\n    private void OnSubmit(InputAction.CallbackContext context)\r\n    {\r\n        if (!isPaused || !isMenuActive) return;\r\n        if (isInSubMenu) return; // submit is handled by the sub menu (if any)\r\n\r\n        if (menuButtons != null && menuButtons.Length > 0)\r\n        {\r\n            Button currentButton = menuButtons[currentSelectionIndex];\r\n            if (!currentButton)\r\n            {\r\n                Debug.LogWarning($\"[PauseMenu] Button at index {currentSelectionIndex} is null.\");\r\n                return;\r\n            }\r\n\r\n            if (currentButton == cognitionButton) OpenCognition();\r\n            else currentButton.onClick.Invoke();\r\n        }\r\n    }\r\n\r\n    public void PauseGame()\r\n    {\r\n        CloseDialogueIfOpen();\r\n\r\n        if (pauseMenuUI) pauseMenuUI.SetActive(true);\r\n        if (cognitionBoardUI) cognitionBoardUI.SetActive(false);\r\n\r\n        Time.timeScale = 0f;\r\n        isPaused = true;\r\n        IsPaused = true;     // NEW: update static flag\r\n        isMenuActive = true;\r\n        isInSubMenu = false;\r\n\r\n        currentSelectionIndex = 0;\r\n        UpdateButtonColors();\r\n\r\n        // Swap maps: disable gameplay, enable UI\r\n        gameplayMap?.Disable(); // NEW: prevents world Interact while paused\r\n        uiActionMap?.Enable();\r\n\r\n        ResetNavState();\r\n    }\r\n\r\n    public void ResumeGame()\r\n    {\r\n        // If board sub-menu is open, close it first to avoid leaving it enabled\r\n        if (isInSubMenu) CloseCognition();\r\n\r\n        if (pauseMenuUI) pauseMenuUI.SetActive(false);\r\n        Time.timeScale = 1f;\r\n        isPaused = false;\r\n        IsPaused = false;    // NEW: update static flag\r\n        isMenuActive = false;\r\n\r\n        // Swap back: disable UI, enable gameplay\r\n        uiActionMap?.Disable();\r\n        gameplayMap?.Enable(); // NEW\r\n\r\n        ResetNavState();\r\n    }\r\n\r\n    private void ResetNavState()\r\n    {\r\n        lastDPadVertical = 0f;\r\n        dpadHoldStartTime = 0f;\r\n    }\r\n\r\n    public void OpenCognition()\r\n    {\r\n        if (!isPaused) PauseGame(); // safety\r\n\r\n        // Hide the button list while board is up (optional; keeps UI clean)\r\n        if (pauseMenuUI) pauseMenuUI.SetActive(false);\r\n\r\n        // Enable the container panel\r\n        if (cognitionBoardUI) cognitionBoardUI.SetActive(true);\r\n\r\n        // IMPORTANT: explicitly enable the board object too (it disables itself in Awake)\r\n        if (cognitionBoard && !cognitionBoard.gameObject.activeSelf)\r\n        {\r\n            cognitionBoard.gameObject.SetActive(true);\r\n            // Optional: refresh layout from save when opening\r\n            cognitionBoard.RestoreLayoutFromSave();\r\n        }\r\n        if (cognitionBoard)\r\n        {\r\n            cognitionBoard.NotifyBoardOpened();\r\n        }\r\n\r\n        // Clear UI selection so Submit doesn't trigger menu buttons behind the board\r\n        if (EventSystem.current) EventSystem.current.SetSelectedGameObject(null);\r\n\r\n        isInSubMenu = true;\r\n        Debug.Log(\"[PauseMenu] Cognition Board opened.\");\r\n    }\r\n\r\n    public void CloseCognition()\r\n    {\r\n        if (cognitionBoardUI) cognitionBoardUI.SetActive(false);\r\n        if (cognitionBoard) cognitionBoard.gameObject.SetActive(false);\r\n\r\n        // Return to the pause menu list\r\n        if (pauseMenuUI) pauseMenuUI.SetActive(true);\r\n\r\n        isInSubMenu = false;\r\n        currentSelectionIndex = 0;\r\n        UpdateButtonColors();\r\n        Debug.Log(\"[PauseMenu] Cognition Board closed.\");\r\n    }\r\n\r\n    public void QuitGame()\r\n    {\r\n#if UNITY_EDITOR\r\n        UnityEditor.EditorApplication.isPlaying = false;\r\n#else\r\n        Application.Quit();\r\n#endif\r\n    }\r\n\r\n    private void UpdateButtonColors()\r\n    {\r\n        if (menuButtons == null || menuButtons.Length == 0) return;\r\n\r\n        for (int i = 0; i < menuButtons.Length; i++)\r\n        {\r\n            var btn = menuButtons[i];\r\n            if (!btn)\r\n            {\r\n                Debug.LogWarning($\"[PauseMenu] Button at index {i} is null.\");\r\n                continue;\r\n            }\r\n\r\n            TMP_Text txt = btn.GetComponentInChildren<TMP_Text>();\r\n            if (txt) txt.color = (i == currentSelectionIndex) ? selectedColor : defaultColor;\r\n        }\r\n    }\r\n\r\n    private void OnCancel(InputAction.CallbackContext context)\r\n    {\r\n        if (!isPaused || !isMenuActive) return;\r\n\r\n        if (isInSubMenu) CloseCognition();\r\n        else ResumeGame();\r\n    }\r\n\r\n    // ---- Helper to avoid static calls ----\r\n    private static void CloseDialogueIfOpen()\r\n    {\r\n        var dm = DialogueManager.Instance;\r\n        if (dm != null && dm.IsActive()) dm.Hide();\r\n    }\r\n    \r\n    public void ResetGame()\r\n{\r\n    // Make sure we’re truly unpaused at the code level\r\n    Time.timeScale = 1f;\r\n    isPaused = false;\r\n    IsPaused = false;\r\n    isMenuActive = false;\r\n    isInSubMenu = false;\r\n\r\n    // Clean UI state\r\n    if (isInSubMenu) CloseCognition();\r\n    if (pauseMenuUI) pauseMenuUI.SetActive(false);\r\n\r\n    // Ensure input maps are sane before the reload\r\n    uiActionMap?.Disable();   // stop reading UI during reload\r\n    gameplayMap?.Enable();    // <- IMPORTANT: don’t leave gameplay disabled\r\n\r\n    // Optional: hard-close any open dialogue to clear guards\r\n    DialogueManager.Instance?.ForceHideAndReset();\r\n\r\n    // Wipe persisted + runtime\r\n    SaveSystem.Instance?.WipeSave(deleteFile: true);\r\n    ClueManager.Instance?.ClearAllRuntime();\r\n\r\n    // Reload current scene\r\n    var scene = SceneManager.GetActiveScene();\r\n    SceneManager.LoadScene(scene.name, LoadSceneMode.Single);\r\n}\r\n\r\n\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "pauseMenuUI",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "menuButtons",
                    "type": "UnityEngine.UI.Button[]",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "cognitionButton",
                    "type": "UnityEngine.UI.Button",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "cognitionBoardUI",
                    "type": "UnityEngine.GameObject",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "cognitionBoard",
                    "type": "CognitionBoard",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "selectedColor",
                    "type": "UnityEngine.Color",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "defaultColor",
                    "type": "UnityEngine.Color",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "inputActions",
                    "type": "UnityEngine.InputSystem.InputActionAsset",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "gameplayMapName",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "moveCooldown",
                    "type": "System.Single",
                    "isPublic": false,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "PauseMenuController"
            ]
        },
        {
            "kind": 0,
            "className": "ProPixelizerTest",
            "namespace": "",
            "fullName": "ProPixelizerTest",
            "filePath": "Assets/Scripts/Shader Scripts/ProPixelizerTest.cs",
            "guid": "15d1f7317b7afd8468d6e59822d24b27",
            "source": "using ProPixelizer;\r\nusing UnityEngine;\r\n\r\npublic class ProPixelizerTest : MonoBehaviour\r\n\r\n{\r\n\r\n    \r\n    // Start is called once before the first execution of Update after the MonoBehaviour is created\r\n    void Start()\r\n    {\r\n        \r\n    }\r\n\r\n}\r\n",
            "serializedFields": [],
            "declaredTypes": [
                "ProPixelizerTest"
            ]
        },
        {
            "kind": 0,
            "className": "SaveSystem",
            "namespace": "",
            "fullName": "SaveSystem",
            "filePath": "Assets/Scripts/Top-Level Managers/SaveSystem.cs",
            "guid": "7e810688e0f4b8e4389367c07fee97f1",
            "source": "using UnityEngine;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.IO;\r\n\r\n[Serializable] public struct Link { public string a; public string b; }\r\n\r\n[Serializable]\r\npublic class BoardLayoutSave\r\n{\r\n    public float zoom = 1f;\r\n    public Vector2 pan = Vector2.zero;\r\n    public Dictionary<string, Vector2> nodePositions = new();\r\n    public List<Link> confirmedLinks = new();\r\n}\r\n\r\n[Serializable]\r\npublic class GameSave\r\n{\r\n    public HashSet<string> discoveredClues = new();\r\n    public HashSet<string> collectedItems = new();\r\n\r\n    // NEW: keep order of discovery\r\n    public List<string> discoveryOrder = new();\r\n\r\n    public BoardLayoutSave board = new();\r\n}\r\n\r\n[DefaultExecutionOrder(-1000)]\r\npublic class SaveSystem : MonoBehaviour\r\n{\r\n    public static SaveSystem Instance { get; private set; }\r\n\r\n    private string SavePath => Path.Combine(Application.persistentDataPath, \"save.json\");\r\n    private GameSave data = new();\r\n\r\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\r\n    private static void EnsureExists()\r\n    {\r\n        if (Instance != null) return;\r\n        var go = new GameObject(\"SaveSystem\");\r\n        go.AddComponent<SaveSystem>();\r\n        DontDestroyOnLoad(go);\r\n    }\r\n\r\n    private void Awake()\r\n    {\r\n        if (Instance && Instance != this) { Destroy(gameObject); return; }\r\n        Instance = this;\r\n        DontDestroyOnLoad(gameObject);\r\n        Load();\r\n        Debug.Log($\"[SaveSystem] Bootstrapped and loaded from '{SavePath}'.\");\r\n    }\r\n\r\n    // --- Persistence API ---\r\n    public void Save()\r\n    {\r\n        try\r\n        {\r\n            var json = JsonUtility.ToJson(data, prettyPrint: true);\r\n            File.WriteAllText(SavePath, json);\r\n            Debug.Log($\"[SaveSystem] Saved to {SavePath}\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Debug.LogError($\"[SaveSystem] Failed to save: {ex}\");\r\n        }\r\n    }\r\n\r\n    public void Load()\r\n    {\r\n        try\r\n        {\r\n            if (File.Exists(SavePath))\r\n            {\r\n                var json = File.ReadAllText(SavePath);\r\n                data = JsonUtility.FromJson<GameSave>(json) ?? new GameSave();\r\n                Debug.Log($\"[SaveSystem] Loaded save from {SavePath}\");\r\n            }\r\n            else\r\n            {\r\n                data = new GameSave();\r\n                Debug.Log(\"[SaveSystem] No existing save found, starting fresh.\");\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Debug.LogError($\"[SaveSystem] Failed to load: {ex}\");\r\n            data = new GameSave();\r\n        }\r\n\r\n        // Backfill if older saves had no discoveryOrder\r\n        if (data.discoveryOrder == null) data.discoveryOrder = new List<string>();\r\n        foreach (var g in data.discoveredClues)\r\n            if (!data.discoveryOrder.Contains(g))\r\n                data.discoveryOrder.Add(g);\r\n    }\r\n\r\n    // --- Item tracking ---\r\n    public void MarkItemCollected(string itemGuid)\r\n    {\r\n        if (!data.collectedItems.Contains(itemGuid))\r\n        {\r\n            data.collectedItems.Add(itemGuid);\r\n            Save();\r\n        }\r\n    }\r\n    public bool IsItemCollected(string itemGuid) => data.collectedItems.Contains(itemGuid);\r\n\r\n    // --- Clue tracking + order ---\r\n    public void MarkClueDiscovered(string clueGuid)\r\n    {\r\n        bool added = data.discoveredClues.Add(clueGuid);\r\n        if (added && !data.discoveryOrder.Contains(clueGuid))\r\n            data.discoveryOrder.Add(clueGuid);\r\n        if (added) Save();\r\n    }\r\n    public IEnumerable<string> GetDiscoveredClues() => data.discoveredClues;\r\n\r\n    // NEW: expose discovery order + index helpers\r\n    public IReadOnlyList<string> GetDiscoveryOrder() => data.discoveryOrder;\r\n    public int GetDiscoveryIndex(string guid)\r\n    {\r\n        if (data.discoveryOrder == null) return int.MaxValue;\r\n        return data.discoveryOrder.IndexOf(guid);\r\n    }\r\n\r\n    // --- Link tracking ---\r\n    public void MarkLinkConfirmed(string a, string b)\r\n    {\r\n        if (!data.board.confirmedLinks.Exists(l => (l.a == a && l.b == b) || (l.a == b && l.b == a)))\r\n        {\r\n            data.board.confirmedLinks.Add(new Link { a = a, b = b });\r\n            Save();\r\n        }\r\n    }\r\n\r\n    // --- Board layout ---\r\n    public void SetNodePosition(string clueGuid, Vector2 anchoredPos)\r\n    {\r\n        data.board.nodePositions[clueGuid] = anchoredPos; Save();\r\n    }\r\n    public void SetBoardZoom(float z) { data.board.zoom = z; Save(); }\r\n    public void SetBoardPan(Vector2 p) { data.board.pan = p; Save(); }\r\n    public BoardLayoutSave GetBoardLayout() => data.board;\r\n\r\n    public IEnumerable<Link> GetConfirmedLinks() => data.board.confirmedLinks;\r\n    public bool IsLinkConfirmed(string a, string b)\r\n    {\r\n        foreach (var l in data.board.confirmedLinks)\r\n            if ((l.a == a && l.b == b) || (l.a == b && l.b == a)) return true;\r\n        return false;\r\n    }\r\n    \r\n    public void WipeSave(bool deleteFile = true)\r\n{\r\n    // Reset in-memory save\r\n    data = new GameSave();\r\n\r\n    // Optionally delete the on-disk file so it's a truly fresh boot next time too\r\n    try\r\n    {\r\n        if (deleteFile && File.Exists(SavePath))\r\n            File.Delete(SavePath);\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        Debug.LogError($\"[SaveSystem] Failed to delete save file: {ex}\");\r\n    }\r\n\r\n    // Not strictly necessary to re-save here (we just wiped),\r\n    // but calling Save() would create a fresh empty file if you want that.\r\n    // Save();\r\n}\r\n\r\n}\r\n",
            "serializedFields": [],
            "declaredTypes": [
                "Link",
                "BoardLayoutSave",
                "GameSave",
                "SaveSystem"
            ]
        },
        {
            "kind": 0,
            "className": "ThirdPersonController",
            "namespace": "",
            "fullName": "ThirdPersonController",
            "filePath": "Assets/Scripts/Top-Level Managers/ThirdPersonController.cs",
            "guid": "2bc0698cdf6dab34fabacef711e3c099",
            "source": "\r\nusing UnityEditor.VersionControl;\r\nusing UnityEngine;\r\n\r\n/*\r\n    This file has a commented version with details about how each line works. \r\n    The commented version contains code that is easier and simpler to read. This file is minified.\r\n*/\r\n\r\n\r\n/// <summary>\r\n/// Main script for third-person movement of the character in the game.\r\n/// Make sure that the object that will receive this script (the player) \r\n/// has the Player tag and the Character Controller component.\r\n/// </summary>\r\npublic class ThirdPersonController : MonoBehaviour\r\n{\r\n\r\n    [Tooltip(\"Speed ​​at which the character moves. It is not affected by gravity or jumping.\")]\r\n    public float velocity = 5f;\r\n    [Tooltip(\"This value is added to the speed value while the character is sprinting.\")]\r\n    public float sprintAdittion = 3.5f;\r\n    [Tooltip(\"The higher the value, the higher the character will jump.\")]\r\n    public float jumpForce = 18f;\r\n    [Tooltip(\"Stay in the air. The higher the value, the longer the character floats before falling.\")]\r\n    public float jumpTime = 0.85f;\r\n    [Space]\r\n    [Tooltip(\"Force that pulls the player down. Changing this value causes all movement, jumping and falling to be changed as well.\")]\r\n    public float gravity = 9.8f;\r\n\r\n    float jumpElapsedTime = 0;\r\n\r\n    // Player states\r\n    bool isJumping = false;\r\n    bool isWalking;\r\n    bool isRunning = false;\r\n    bool isCrouching = false;\r\n\r\n    // Inputs\r\n    float inputHorizontal;\r\n    float inputVertical;\r\n    bool inputJump;\r\n    bool inputCrouch;\r\n    bool inputSprint;\r\n\r\n    private Vector3 stairEntryPosition;\r\n    private bool OnStairs = false;\r\n    private bool IsAscending = false;\r\n\r\n    private bool IsDescending = false;\r\n\r\n    public bool isLocked = false;\r\n\r\n    Animator animator;\r\n    CharacterController cc;\r\n\r\n\r\n    void Start()\r\n    {\r\n        cc = GetComponent<CharacterController>();\r\n        animator = GetComponent<Animator>();\r\n\r\n        // Message informing the user that they forgot to add an animator\r\n        if (animator == null)\r\n            Debug.LogWarning(\"Hey buddy, you don't have the Animator component in your player. Without it, the animations won't work.\");\r\n    }\r\n\r\n\r\n    // Update is only being used here to identify keys and trigger animations\r\n    void Update()\r\n    {\r\n\r\n        if (isLocked)\r\n        {\r\n            return;\r\n        }\r\n        if (DoorInteraction.isPlayerNear && (Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetKeyDown(KeyCode.Return)))\r\n\r\n        {\r\n            Debug.Log(\"[Input] Triggering door sequence\");\r\n            // Find the DoorTriggerZone component in the scene and call ActivateDoorSequence\r\n            DoorTriggerZone doorZone = FindFirstObjectByType<DoorTriggerZone>();\r\n            if (doorZone != null)\r\n            {\r\n                doorZone.ActivateDoorSequence();\r\n            }\r\n            else\r\n            {\r\n                Debug.LogWarning(\"No DoorTriggerZone found in the scene.\");\r\n            }\r\n        }\r\n\r\n        //Debug.Log(\"OnStairs = \" + OnStairs);\r\n        // Input checkers\r\n        inputHorizontal = Input.GetAxis(\"Horizontal\");\r\n        inputVertical = Input.GetAxis(\"Vertical\");\r\n        inputJump = Input.GetAxis(\"Jump\") == 1f;\r\n        inputSprint = Input.GetKey(KeyCode.JoystickButton8);\r\n        // Unfortunately GetAxis does not work with GetKeyDown, so inputs must be taken individually\r\n        inputCrouch = Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.JoystickButton1);\r\n\r\n        // Create input direction\r\n        Vector3 inputDirection = new Vector3(inputHorizontal, 0, inputVertical).normalized;\r\n\r\n        // Determine if player is moving\r\n        bool isMoving = inputDirection.magnitude >= 0.1f;\r\n\r\n        if (isMoving)\r\n        {\r\n            // Set animator parameters\r\n            animator.SetBool(\"IsWalking\", true);\r\n            animator.SetBool(\"IsRunning\", isRunning);\r\n        }\r\n        else\r\n        {\r\n            // Not moving\r\n            animator.SetBool(\"IsWalking\", false);\r\n            animator.SetBool(\"IsRunning\", false);\r\n        }\r\n\r\n        // Check if you pressed the crouch input key and change the player's state\r\n        // if (inputCrouch)\r\n        //     isCrouching = !isCrouching;\r\n\r\n        // Run and Crouch animation\r\n        // If dont have animator component, this block wont run\r\n        if (cc.isGrounded && animator != null)\r\n        {\r\n\r\n            // Crouch\r\n            // Note: The crouch animation does not shrink the character's collider\r\n            // animator.SetBool(\"crouch\", isCrouching);\r\n\r\n            // Run\r\n            float minimumSpeed = 0.9f;\r\n            animator.SetBool(\"IsWalking\", cc.velocity.magnitude > minimumSpeed);\r\n\r\n            // Sprint\r\n            isRunning = cc.velocity.magnitude > minimumSpeed && inputSprint;\r\n            animator.SetBool(\"IsRunning\", isRunning);\r\n\r\n        }\r\n\r\n        // Jump animation\r\n        // if (animator != null)\r\n        //   animator.SetBool(\"air\", cc.isGrounded == false);\r\n\r\n        // Handle can jump or not\r\n        // if (inputJump && cc.isGrounded)\r\n        //  {\r\n        //    isJumping = true;\r\n        // Disable crounching when jumping\r\n        //isCrouching = false; \r\n        //}\r\n\r\n        HeadHittingDetect();\r\n\r\n        if (OnStairs)\r\n        {\r\n            float verticalInput = inputVertical;\r\n\r\n            if (verticalInput > 0)\r\n            {\r\n                IsAscending = true;\r\n                IsDescending = false;\r\n            }\r\n            else if (verticalInput < 0)\r\n            {\r\n                IsDescending = true;\r\n                IsAscending = false;\r\n            }\r\n            else\r\n            {\r\n                IsAscending = false;\r\n                IsDescending = false;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            IsAscending = false;\r\n            IsDescending = false;\r\n        }\r\n\r\n        // Update animator parameters\r\n        animator.SetBool(\"IsAscending\", IsAscending);\r\n        animator.SetBool(\"IsDescending\", IsDescending);\r\n\r\n    }\r\n\r\n\r\n    // With the inputs and animations defined, FixedUpdate is responsible for applying movements and actions to the player\r\n    private void FixedUpdate()\r\n    {\r\n\r\n         if (isLocked)\r\n    {\r\n        // Ensure no motion is applied this frame (CharacterController only moves when Move is called).\r\n        // We do NOT call cc.Move here.\r\n        return;\r\n    }\r\n\r\n        // Sprinting velocity boost or crounching desacelerate\r\n        float velocityAdittion = 0;\r\n        if (isRunning)\r\n            velocityAdittion = sprintAdittion;\r\n        if (isCrouching)\r\n            velocityAdittion = -(velocity * 0.50f); // -50% velocity\r\n        if (IsAscending)\r\n            velocityAdittion = -(velocity * 0.6f);\r\n        if (IsDescending)\r\n            velocityAdittion = -(velocity * 0.4f);\r\n\r\n\r\n        // Direction movement\r\n        float directionX = inputHorizontal * (velocity + velocityAdittion) * Time.deltaTime;\r\n        float directionZ = inputVertical * (velocity + velocityAdittion) * Time.deltaTime;\r\n        float directionY = 0;\r\n\r\n        // Jump handler\r\n        if (isJumping)\r\n        {\r\n\r\n            // Apply inertia and smoothness when climbing the jump\r\n            // It is not necessary when descending, as gravity itself will gradually pulls\r\n            directionY = Mathf.SmoothStep(jumpForce, jumpForce * 0.30f, jumpElapsedTime / jumpTime) * Time.deltaTime;\r\n\r\n            // Jump timer\r\n            jumpElapsedTime += Time.deltaTime;\r\n            if (jumpElapsedTime >= jumpTime)\r\n            {\r\n                isJumping = false;\r\n                jumpElapsedTime = 0;\r\n            }\r\n        }\r\n\r\n        // Add gravity to Y axis\r\n        directionY = directionY - gravity * Time.deltaTime;\r\n\r\n\r\n        // --- Character rotation --- \r\n\r\n        Vector3 forward = Camera.main.transform.forward;\r\n        Vector3 right = Camera.main.transform.right;\r\n\r\n        forward.y = 0;\r\n        right.y = 0;\r\n\r\n        forward.Normalize();\r\n        right.Normalize();\r\n\r\n        // Relate the front with the Z direction (depth) and right with X (lateral movement)\r\n        forward = forward * directionZ;\r\n        right = right * directionX;\r\n\r\n        if (directionX != 0 || directionZ != 0)\r\n        {\r\n            float angle = Mathf.Atan2(forward.x + right.x, forward.z + right.z) * Mathf.Rad2Deg;\r\n            Quaternion rotation = Quaternion.Euler(0, angle, 0);\r\n            transform.rotation = Quaternion.Slerp(transform.rotation, rotation, 0.15f);\r\n        }\r\n\r\n        // --- End rotation ---\r\n\r\n\r\n        Vector3 verticalDirection = Vector3.up * directionY;\r\n        Vector3 horizontalDirection = forward + right;\r\n\r\n        Vector3 moviment = verticalDirection + horizontalDirection;\r\n        cc.Move(moviment);\r\n\r\n    }\r\n\r\n\r\n    //This function makes the character end his jump if he hits his head on something\r\n    void HeadHittingDetect()\r\n    {\r\n        float headHitDistance = 1.1f;\r\n        Vector3 ccCenter = transform.TransformPoint(cc.center);\r\n        float hitCalc = cc.height / 2f * headHitDistance;\r\n\r\n        // Uncomment this line to see the Ray drawed in your characters head\r\n        // Debug.DrawRay(ccCenter, Vector3.up * headHeight, Color.red);\r\n\r\n        if (Physics.Raycast(ccCenter, Vector3.up, hitCalc))\r\n        {\r\n            jumpElapsedTime = 0;\r\n            isJumping = false;\r\n        }\r\n    }\r\n    void OnTriggerEnter(Collider other)\r\n    {\r\n        //Debug.Log(\"Trigger entered with: \" + other.gameObject.name);\r\n        if (other.CompareTag(\"Stairs\"))\r\n        {\r\n            //Debug.Log(\"Player entered stairs trigger.\");\r\n            OnStairs = true;\r\n            stairEntryPosition = transform.position; // Save position at entry\r\n\r\n        }\r\n    }\r\n\r\n    void OnTriggerExit(Collider other)\r\n    {\r\n        //Debug.Log(\"Trigger exited with: \" + other.gameObject.name);\r\n        if (other.CompareTag(\"Stairs\"))\r\n        {\r\n            //Debug.Log(\"Player exited stairs trigger.\");\r\n            OnStairs = false;\r\n            IsAscending = false;\r\n            IsDescending = false;\r\n\r\n        }\r\n    }\r\n\r\n    public void Teleport(Vector3 position)\r\n    {\r\n        transform.position = position;\r\n    }\r\n\r\n    private void OnEnable()\r\n    {\r\n        DialogueManager.OnDialogActiveChanged += HandleDialogToggle;\r\n    }\r\n\r\n    private void OnDisable()\r\n    {\r\n        DialogueManager.OnDialogActiveChanged -= HandleDialogToggle;\r\n    }\r\n\r\nprivate void HandleDialogToggle(bool active)\r\n{\r\n    isLocked = active;\r\n\r\n    // Stop Animator root motion from moving the character while locked.\r\n    if (animator) animator.applyRootMotion = !active;\r\n\r\n    if (active)\r\n    {\r\n        // Nuke any residual input/anim state so the pose settles.\r\n        inputHorizontal = 0f;\r\n        inputVertical = 0f;\r\n        isRunning = false;\r\n        isCrouching = false;\r\n\r\n        if (animator)\r\n        {\r\n            animator.SetBool(\"IsWalking\", false);\r\n            animator.SetBool(\"IsRunning\", false);\r\n            animator.SetBool(\"IsAscending\", false);\r\n            animator.SetBool(\"IsDescending\", false);\r\n        }\r\n    }\r\n\r\n    Debug.Log($\"[ThirdPersonController] Dialog lock={(active ? \"ON\" : \"OFF\")} | applyRootMotion={(animator ? animator.applyRootMotion : false)}\");\r\n}\r\n\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "velocity",
                    "type": "System.Single",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "sprintAdittion",
                    "type": "System.Single",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "jumpForce",
                    "type": "System.Single",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "jumpTime",
                    "type": "System.Single",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "gravity",
                    "type": "System.Single",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "isLocked",
                    "type": "System.Boolean",
                    "isPublic": true,
                    "hasSerializeField": false
                }
            ],
            "declaredTypes": [
                "ThirdPersonController"
            ]
        },
        {
            "kind": 1,
            "className": "ClueData",
            "namespace": "",
            "fullName": "ClueData",
            "filePath": "Assets/Scripts/DataScripts/ClueData.cs",
            "guid": "6234d3eed4f6dea4c94d7bd266b80334",
            "source": "using UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n[CreateAssetMenu(fileName = \"ClueData\", menuName = \"Game Data/Clue Data\")]\r\npublic class ClueData : ScriptableObject\r\n{\r\n    [SerializeField, HideInInspector] private string guid;\r\n    public string Guid => string.IsNullOrEmpty(guid) ? (guid = System.Guid.NewGuid().ToString()) : guid;\r\n\r\n    [Header(\"Core\")]\r\n    public string clueName;\r\n    [TextArea] public string description;\r\n    public Sprite icon;\r\n    public ClueCategory category;\r\n\r\n    [Header(\"Related Clues (drag & drop)\")]\r\n    [Tooltip(\"Drag other ClueData assets here. We'll keep the GUID list in sync automatically.\")]\r\n    public List<ClueData> relatedClues = new();\r\n\r\n    // Kept for runtime/board code. Hidden so you don't edit by hand.\r\n    [SerializeField, HideInInspector] public List<string> relatedClueGuids = new();\r\n\r\n    public enum ClueCategory { Person, Object, Location, Event }\r\n\r\n#if UNITY_EDITOR\r\n    private void OnValidate()\r\n    {\r\n        // Ensure we have a GUID\r\n        if (string.IsNullOrEmpty(guid))\r\n            guid = System.Guid.NewGuid().ToString();\r\n\r\n        // Keep GUID list in sync with the drag-and-drop list\r\n        SyncRelatedGuidList();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Copies relatedClues -> relatedClueGuids. Removes nulls/duplicates/self.\r\n    /// </summary>\r\n    private void SyncRelatedGuidList()\r\n    {\r\n        if (relatedClueGuids == null) relatedClueGuids = new List<string>();\r\n        var set = new HashSet<string>();\r\n\r\n        if (relatedClues != null)\r\n        {\r\n            foreach (var cd in relatedClues)\r\n            {\r\n                if (!cd) continue;\r\n                var g = cd.Guid;            // forces GUID creation for each related asset\r\n                if (string.IsNullOrEmpty(g)) continue;\r\n                if (g == Guid) continue;    // no self-link\r\n                set.Add(g);\r\n            }\r\n        }\r\n\r\n        // Write back only if changed (avoids dirtying assets unnecessarily)\r\n        bool changed = false;\r\n        if (set.Count != relatedClueGuids.Count) changed = true;\r\n        else\r\n        {\r\n            foreach (var g in relatedClueGuids)\r\n                if (!set.Contains(g)) { changed = true; break; }\r\n        }\r\n\r\n        if (changed)\r\n        {\r\n            relatedClueGuids.Clear();\r\n            relatedClueGuids.AddRange(set);\r\n            UnityEditor.EditorUtility.SetDirty(this);\r\n        }\r\n    }\r\n\r\n    // Optional helpers to speed up authoring\r\n\r\n    [ContextMenu(\"Related ▸ Make Links Mutual\")]\r\n    private void MakeLinksMutual()\r\n    {\r\n        // Ensure every related clue also lists *this* clue.\r\n        foreach (var other in relatedClues)\r\n        {\r\n            if (!other) continue;\r\n            if (!other.relatedClues.Contains(this))\r\n            {\r\n                other.relatedClues.Add(this);\r\n                other.SyncRelatedGuidList();\r\n                UnityEditor.EditorUtility.SetDirty(other);\r\n            }\r\n        }\r\n        SyncRelatedGuidList();\r\n        UnityEditor.EditorUtility.SetDirty(this);\r\n        Debug.Log($\"[{name}] Links made mutual with {relatedClues.Count} clues.\");\r\n    }\r\n\r\n    [ContextMenu(\"Related ▸ Clear Nulls & Duplicates\")]\r\n    private void CleanRelatedList()\r\n    {\r\n        var seen = new HashSet<ClueData>();\r\n        for (int i = relatedClues.Count - 1; i >= 0; i--)\r\n        {\r\n            var c = relatedClues[i];\r\n            if (!c || c == this || !seen.Add(c))\r\n                relatedClues.RemoveAt(i);\r\n        }\r\n        SyncRelatedGuidList();\r\n        UnityEditor.EditorUtility.SetDirty(this);\r\n    }\r\n#endif\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "guid",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "clueName",
                    "type": "System.String",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "description",
                    "type": "System.String",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "icon",
                    "type": "UnityEngine.Sprite",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "category",
                    "type": "ClueData+ClueCategory",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "relatedClues",
                    "type": "System.Collections.Generic.List`1[[ClueData, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "relatedClueGuids",
                    "type": "System.Collections.Generic.List`1[[System.String, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]",
                    "isPublic": true,
                    "hasSerializeField": true
                }
            ],
            "declaredTypes": [
                "ClueData",
                "ClueCategory"
            ]
        },
        {
            "kind": 1,
            "className": "DialogueGraph",
            "namespace": "",
            "fullName": "DialogueGraph",
            "filePath": "Assets/Scripts/Dialogue/DialogueGraph.cs",
            "guid": "7bff2d379aba5794ca81f083f1e04bb5",
            "source": "using System;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\n\r\n[CreateAssetMenu(fileName = \"DialogueGraph\", menuName = \"Game Data/Dialogue Graph\")]\r\npublic class DialogueGraph : ScriptableObject\r\n{\r\n    [SerializeField, HideInInspector] private string guid;\r\n    public string Guid => string.IsNullOrEmpty(guid) ? (guid = System.Guid.NewGuid().ToString()) : guid;\r\n\r\n    [Tooltip(\"GUID of the node where this graph starts.\")]\r\n    public string startGuid;\r\n\r\n    [Tooltip(\"All nodes in this graph.\")]\r\n    public List<DialogueNode> nodes = new();\r\n\r\n    public DialogueNode Get(string nodeGuid) => nodes.Find(n => n != null && n.guid == nodeGuid);\r\n\r\n#if UNITY_EDITOR\r\n    private void OnValidate()\r\n    {\r\n        bool changed = false;\r\n\r\n        if (string.IsNullOrEmpty(guid))\r\n        {\r\n            guid = System.Guid.NewGuid().ToString();\r\n            changed = true;\r\n        }\r\n\r\n        if (nodes != null)\r\n        {\r\n            foreach (var n in nodes)\r\n            {\r\n                if (n == null) continue;\r\n\r\n                if (string.IsNullOrEmpty(n.guid))\r\n                {\r\n                    n.guid = System.Guid.NewGuid().ToString();\r\n                    changed = true;\r\n                }\r\n\r\n                if (n.choices == null)\r\n                {\r\n                    n.choices = new List<DialogueChoice>();\r\n                    changed = true;\r\n                }\r\n\r\n                if (n.isChoice && n.choices.Count > 0)\r\n                {\r\n                    n.defaultChoiceIndex = Mathf.Clamp(n.defaultChoiceIndex, 0, n.choices.Count - 1);\r\n                }\r\n                else if (!n.isChoice)\r\n                {\r\n                    n.defaultChoiceIndex = 0; // unused when not a choice\r\n                }\r\n            }\r\n        }\r\n\r\n        if (string.IsNullOrEmpty(startGuid) && nodes.Count > 0 && nodes[0] != null)\r\n        {\r\n            startGuid = nodes[0].guid;\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) UnityEditor.EditorUtility.SetDirty(this);\r\n    }\r\n#endif\r\n}\r\n\r\n[Serializable]\r\npublic class DialogueNode\r\n{\r\n    [Tooltip(\"Unique ID for this node. Auto-filled.\")]\r\n    public string guid = \"\";\r\n\r\n    [Tooltip(\"If true, this node shows choices; otherwise it shows 'text' and then goes to 'nextGuid'.\")]\r\n    public bool isChoice;\r\n\r\n    [TextArea]\r\n    [Tooltip(\"Text to display (for non-choice nodes) or the prompt (for choice nodes).\")]\r\n    public string text;\r\n\r\n    [Tooltip(\"Choices shown when isChoice == true.\")]\r\n    public List<DialogueChoice> choices = new();\r\n\r\n    [Tooltip(\"Next node to go to when this is NOT a choice node.\")]\r\n    public string nextGuid;\r\n\r\n    [Tooltip(\"Which option is selected if the player presses B/Cancel on this choice node.\")]\r\n    public int defaultChoiceIndex = 0;\r\n}\r\n\r\n[Serializable]\r\npublic class DialogueChoice\r\n{\r\n    [Tooltip(\"Label shown to the player, e.g., Yes/No.\")]\r\n    public string label = \"Option\";\r\n\r\n    [Tooltip(\"Node GUID to follow if this option is chosen.\")]\r\n    public string nextGuid;\r\n\r\n    [Tooltip(\"Optional meaning so gameplay can react (e.g., PickupYes / PickupNo / None).\")]\r\n    public ChoiceSemantic semantic = ChoiceSemantic.None;\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "guid",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "startGuid",
                    "type": "System.String",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "nodes",
                    "type": "System.Collections.Generic.List`1[[DialogueNode, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]",
                    "isPublic": true,
                    "hasSerializeField": false
                }
            ],
            "declaredTypes": [
                "DialogueGraph",
                "DialogueNode",
                "DialogueChoice"
            ]
        },
        {
            "kind": 1,
            "className": "DialogueGraphEditor",
            "namespace": "",
            "fullName": "DialogueGraphEditor",
            "filePath": "Assets/Scripts/Dialogue/Editor/DialogueGraphEditor.cs",
            "guid": "aa8c53a1705fad542b52b0d8be4495ed",
            "source": "#if UNITY_EDITOR\r\nusing UnityEditor;\r\nusing UnityEngine;\r\n\r\n// ---------- Custom inspector for the graph asset ----------\r\n[CustomEditor(typeof(DialogueGraph))]\r\npublic class DialogueGraphEditor : Editor\r\n{\r\n    SerializedProperty startGuidProp;\r\n    SerializedProperty nodesProp;\r\n\r\n    void OnEnable()\r\n    {\r\n        startGuidProp = serializedObject.FindProperty(\"startGuid\");\r\n        nodesProp     = serializedObject.FindProperty(\"nodes\");\r\n    }\r\n\r\n    public override void OnInspectorGUI()\r\n    {\r\n        serializedObject.Update();\r\n\r\n        // Title\r\n        EditorGUILayout.LabelField(\"Dialogue Graph\", EditorStyles.boldLabel);\r\n        EditorGUILayout.Space(2);\r\n\r\n        // Start Node popup\r\n        DrawStartNodePopup();\r\n\r\n        EditorGUILayout.Space(6);\r\n\r\n        // Nodes list (DialogueNodeDrawer handles conditional fields)\r\n        EditorGUILayout.PropertyField(nodesProp, new GUIContent(\"Nodes\"), true);\r\n\r\n        serializedObject.ApplyModifiedProperties();\r\n    }\r\n\r\n    private void DrawStartNodePopup()\r\n    {\r\n        var graph = (DialogueGraph)target;\r\n\r\n        // Build labels & map GUIDs to indices\r\n        int count = nodesProp.arraySize;\r\n        string[] labels = new string[count];\r\n        string[] guids  = new string[count];\r\n\r\n        int currentIndex = -1;\r\n\r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            var elem = nodesProp.GetArrayElementAtIndex(i);\r\n            var guidProp   = elem.FindPropertyRelative(\"guid\");\r\n            var isChoice   = elem.FindPropertyRelative(\"isChoice\").boolValue;\r\n            var textProp   = elem.FindPropertyRelative(\"text\");\r\n\r\n            string guid = guidProp.stringValue;\r\n            guids[i] = guid;\r\n\r\n            string preview = textProp.stringValue;\r\n            if (string.IsNullOrEmpty(preview)) preview = isChoice ? \"(Choice node)\" : \"(Text node)\";\r\n            if (preview.Length > 40) preview = preview.Substring(0, 40) + \"…\";\r\n\r\n            labels[i] = $\"{i}: {(isChoice ? \"[Choice] \" : \"\")}{preview}\";\r\n\r\n            if (!string.IsNullOrEmpty(graph.startGuid) && graph.startGuid == guid)\r\n                currentIndex = i;\r\n        }\r\n\r\n        int newIndex = EditorGUILayout.Popup(new GUIContent(\"Start Node\"), Mathf.Max(0, currentIndex), labels);\r\n\r\n        if (newIndex >= 0 && newIndex < guids.Length)\r\n        {\r\n            string newGuid = guids[newIndex];\r\n            if (startGuidProp.stringValue != newGuid)\r\n            {\r\n                startGuidProp.stringValue = newGuid;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// ---------- Property drawer for DialogueNode (conditional fields) ----------\r\n[CustomPropertyDrawer(typeof(DialogueNode))]\r\npublic class DialogueNodeDrawer : PropertyDrawer\r\n{\r\n    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)\r\n    {\r\n        // Calculate height based on which fields are shown\r\n        float h = 0f;\r\n        float line = EditorGUIUtility.singleLineHeight;\r\n        float pad  = EditorGUIUtility.standardVerticalSpacing;\r\n\r\n        var guid     = property.FindPropertyRelative(\"guid\");\r\n        var isChoice = property.FindPropertyRelative(\"isChoice\");\r\n        var text     = property.FindPropertyRelative(\"text\");\r\n        var choices  = property.FindPropertyRelative(\"choices\");\r\n        var nextGuid = property.FindPropertyRelative(\"nextGuid\");\r\n        var defIdx   = property.FindPropertyRelative(\"defaultChoiceIndex\");\r\n\r\n        h += line + pad; // foldout header by PropertyField\r\n        h += line + pad; // guid (readonly-ish)\r\n        h += line + pad; // isChoice\r\n        h += EditorGUI.GetPropertyHeight(text, true) + pad;\r\n\r\n        bool showChoice = isChoice.boolValue;\r\n\r\n        if (showChoice)\r\n        {\r\n            h += EditorGUI.GetPropertyHeight(choices, true) + pad;\r\n            h += line + pad; // default idx\r\n        }\r\n        else\r\n        {\r\n            h += EditorGUI.GetPropertyHeight(nextGuid, true) + pad;\r\n        }\r\n\r\n        h += pad; // extra bottom spacing\r\n        return h;\r\n    }\r\n\r\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\r\n    {\r\n        EditorGUI.BeginProperty(position, label, property);\r\n\r\n        var guid     = property.FindPropertyRelative(\"guid\");\r\n        var isChoice = property.FindPropertyRelative(\"isChoice\");\r\n        var text     = property.FindPropertyRelative(\"text\");\r\n        var choices  = property.FindPropertyRelative(\"choices\");\r\n        var nextGuid = property.FindPropertyRelative(\"nextGuid\");\r\n        var defIdx   = property.FindPropertyRelative(\"defaultChoiceIndex\");\r\n\r\n        float line = EditorGUIUtility.singleLineHeight;\r\n        float pad  = EditorGUIUtility.standardVerticalSpacing;\r\n        Rect r = new Rect(position.x, position.y, position.width, line);\r\n\r\n        // Box group\r\n        GUI.Box(position, GUIContent.none);\r\n        r.x += 6; r.width -= 12;\r\n        float contentWidth = r.width;\r\n\r\n        // Title\r\n        EditorGUI.LabelField(r, \"Dialogue Node\", EditorStyles.boldLabel);\r\n        r.y += line + pad;\r\n\r\n        // GUID (display and \"Regenerate\" button)\r\n        Rect guidRect = new Rect(r.x, r.y, contentWidth - 110, line);\r\n        Rect regenBtn = new Rect(r.x + contentWidth - 100, r.y, 100, line);\r\n\r\n        using (new EditorGUI.DisabledScope(true))\r\n            EditorGUI.TextField(guidRect, \"GUID\", string.IsNullOrEmpty(guid.stringValue) ? \"(auto)\" : guid.stringValue);\r\n\r\n        if (GUI.Button(regenBtn, \"Regenerate\"))\r\n            guid.stringValue = System.Guid.NewGuid().ToString();\r\n\r\n        r.y += line + pad;\r\n\r\n        // Is Choice\r\n        EditorGUI.PropertyField(r, isChoice);\r\n        r.y += line + pad;\r\n\r\n        // Text / Prompt\r\n        EditorGUI.PropertyField(new Rect(r.x, r.y, contentWidth, EditorGUI.GetPropertyHeight(text, true)), text, new GUIContent(isChoice.boolValue ? \"Prompt\" : \"Text\"), true);\r\n        r.y += EditorGUI.GetPropertyHeight(text, true) + pad;\r\n\r\n        if (isChoice.boolValue)\r\n        {\r\n            // Choices\r\n            EditorGUI.PropertyField(new Rect(r.x, r.y, contentWidth, EditorGUI.GetPropertyHeight(choices, true)), choices, true);\r\n            r.y += EditorGUI.GetPropertyHeight(choices, true) + pad;\r\n\r\n            // Default Choice Index (clamped)\r\n            int oldIdx = defIdx.intValue;\r\n            int newIdx = EditorGUI.IntField(new Rect(r.x, r.y, contentWidth, line), \"Default Choice Index\", oldIdx);\r\n            if (choices.arraySize > 0)\r\n                defIdx.intValue = Mathf.Clamp(newIdx, 0, choices.arraySize - 1);\r\n            else\r\n                defIdx.intValue = 0;\r\n\r\n            r.y += line + pad;\r\n        }\r\n        else\r\n        {\r\n            // Next GUID\r\n            EditorGUI.PropertyField(new Rect(r.x, r.y, contentWidth, EditorGUI.GetPropertyHeight(nextGuid, true)), nextGuid, true);\r\n            r.y += EditorGUI.GetPropertyHeight(nextGuid, true) + pad;\r\n        }\r\n\r\n        EditorGUI.EndProperty();\r\n    }\r\n}\r\n#endif\r\n",
            "serializedFields": [],
            "declaredTypes": [
                "DialogueGraphEditor",
                "DialogueNodeDrawer"
            ]
        },
        {
            "kind": 1,
            "className": "ItemData",
            "namespace": "",
            "fullName": "ItemData",
            "filePath": "Assets/Scripts/DataScripts/ItemData.cs",
            "guid": "1fe8da9fd39a7a14c96cdf9a336c2aaa",
            "source": "using UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n[CreateAssetMenu(fileName = \"ItemData\", menuName = \"Game Data/Item Data\")]\r\npublic class ItemData : ScriptableObject\r\n{\r\n    [SerializeField, HideInInspector] private string guid;\r\n    public string Guid => string.IsNullOrEmpty(guid) ? (guid = System.Guid.NewGuid().ToString()) : guid;\r\n\r\n    public int itemID;\r\n    public string itemName;\r\n    [TextArea] public string description;\r\n    public Sprite icon;\r\n\r\n    public bool canBeClue;\r\n    public ClueData clueData;\r\n\r\n    [Header(\"Dialogue (linear list)\")]\r\n    public List<DialogueBlock> dialogue = new List<DialogueBlock>();\r\n\r\n    [Header(\"Dialogue (graph-based)\")]\r\n    public DialogueGraph graph;   // <— this is what ItemInteraction is reading\r\n\r\n    [Header(\"Optional follow-ups after PickupYesNo (linear mode)\")]\r\n    [TextArea] public string afterYesText;\r\n    [TextArea] public string afterNoText;\r\n\r\n#if UNITY_EDITOR\r\n    private void OnValidate()\r\n    {\r\n        if (string.IsNullOrEmpty(guid))\r\n            guid = System.Guid.NewGuid().ToString();\r\n    }\r\n#endif\r\n}\r\n\r\npublic enum BlockType { Text, Choice }\r\npublic enum ChoiceSemantic\r\n{\r\n    None,\r\n    PickupYes,     // explicit YES\r\n    PickupNo,      // explicit NO\r\n\r\n    // Legacy (linear list mode only). Leave if you still use the old yesIndex logic.\r\n    PickupYesNo\r\n}\r\n\r\n[System.Serializable]\r\npublic class DialogueBlock\r\n{\r\n    public BlockType type = BlockType.Text;\r\n\r\n    // Text bubble (or choice prompt if you want to reuse this for prompts)\r\n    [TextArea] public string text;\r\n\r\n    // Choice-only fields\r\n    public string prompt;\r\n    public List<string> options = new List<string> { \"Yes\", \"No\" };\r\n    public int defaultIndex = 0;\r\n    public int yesIndex = 0;\r\n    public ChoiceSemantic semantic = ChoiceSemantic.None;\r\n}\r\n",
            "serializedFields": [
                {
                    "name": "guid",
                    "type": "System.String",
                    "isPublic": false,
                    "hasSerializeField": true
                },
                {
                    "name": "itemID",
                    "type": "System.Int32",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "itemName",
                    "type": "System.String",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "description",
                    "type": "System.String",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "icon",
                    "type": "UnityEngine.Sprite",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "canBeClue",
                    "type": "System.Boolean",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "clueData",
                    "type": "ClueData",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "dialogue",
                    "type": "System.Collections.Generic.List`1[[DialogueBlock, Assembly-CSharp, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "graph",
                    "type": "DialogueGraph",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "afterYesText",
                    "type": "System.String",
                    "isPublic": true,
                    "hasSerializeField": false
                },
                {
                    "name": "afterNoText",
                    "type": "System.String",
                    "isPublic": true,
                    "hasSerializeField": false
                }
            ],
            "declaredTypes": [
                "ItemData",
                "BlockType",
                "ChoiceSemantic",
                "DialogueBlock"
            ]
        }
    ]
}